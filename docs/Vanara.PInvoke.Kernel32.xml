<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Vanara.PInvoke.Kernel32</name>
  </assembly>
  <members>
    <member name="T:Vanara.InteropServices.LocalMemoryMethods">
      <summary>Unmanaged memory methods for local heap.</summary>
    </member>
    <member name="M:Vanara.InteropServices.LocalMemoryMethods.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Vanara.InteropServices.LocalMemoryMethods</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.AllocMem">
      <summary>Gets the allocation method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.AllocSecureStringAnsi">
      <summary>Gets the Ansi <see cref="T:System.Security.SecureString" /> allocation method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.AllocSecureStringUni">
      <summary>Gets the Unicode <see cref="T:System.Security.SecureString" /> allocation method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.AllocStringAnsi">
      <summary>Gets the Ansi string allocation method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.AllocStringUni">
      <summary>Gets the Unicode string allocation method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.FreeMem">
      <summary>Gets the free method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.FreeSecureStringAnsi">
      <summary>Gets the Ansi <see cref="T:System.Security.SecureString" /> free method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.FreeSecureStringUni">
      <summary>Gets the Unicode <see cref="T:System.Security.SecureString" /> free method.</summary>
    </member>
    <member name="P:Vanara.InteropServices.LocalMemoryMethods.ReAllocMem">
      <summary>Gets the reallocation method.</summary>
    </member>
    <member name="T:Vanara.InteropServices.SafeLocalHandle">
      <summary>A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for memory allocated via LocalAlloc.</summary>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.#ctor(System.Byte[])">
      <summary>Allocates from unmanaged memory to represent an array of pointers and marshals the unmanaged pointers (IntPtr) to the native array equivalent.</summary>
      <param name="bytes">Array of unmanaged pointers</param>
      <returns>SafeLocalHandle object to an native (unmanaged) array of pointers</returns>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.#ctor(System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> class.</summary>
      <param name="size">The size of memory to allocate, in bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">size - The value of this argument must be non-negative</exception>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.#ctor(System.IntPtr,System.Int32,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> class.</summary>
      <param name="handle">The handle.</param>
      <param name="size">The size of memory allocated to the handle, in bytes.</param>
      <param name="ownsHandle">if set to <c>true</c> if this class is responsible for freeing the memory on disposal.</param>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.#ctor(System.IntPtr[])">
      <summary>Allocates from unmanaged memory to represent an array of pointers and marshals the unmanaged pointers (IntPtr) to the native array equivalent.</summary>
      <param name="values">Array of unmanaged pointers</param>
      <returns>SafeLocalHandle object to an native (unmanaged) array of pointers</returns>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.#ctor(System.String)">
      <summary>Allocates from unmanaged memory to represent a Unicode string (WSTR) and marshal this to a native PWSTR.</summary>
      <param name="s">The string value.</param>
      <returns>SafeLocalHandle object to an native (unmanaged) Unicode string</returns>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.CreateFromList``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
      <summary>
            Allocates from unmanaged memory to represent a structure with a variable length array at the end and marshal these structure elements. It is the
            callers responsibility to marshal what precedes the trailing array into the unmanaged memory. ONLY structures with attribute StructLayout of
            LayoutKind.Sequential are supported.
            </summary>
      <param name="values">Collection of structure objects</param>
      <param name="count">Number of items in <paramref name="values" />.</param>
      <param name="prefixBytes">Number of bytes preceding the trailing array of structures</param>
      <typeparam name="T">Type of the trailing array of structures</typeparam>
      <returns>
        <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> object to an native (unmanaged) structure with a trail array of structures</returns>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.CreateFromStringList(System.Collections.Generic.IEnumerable{System.String},Vanara.InteropServices.StringListPackMethod,System.Runtime.InteropServices.CharSet,System.Int32)">
      <summary>Allocates from unmanaged memory sufficient memory to hold an array of strings.</summary>
      <param name="values">The list of strings.</param>
      <param name="packing">The packing type for the strings.</param>
      <param name="charSet">The character set to use for the strings.</param>
      <param name="prefixBytes">Number of bytes preceding the trailing strings.</param>
      <returns>
        <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> object to an native (unmanaged) array of strings stored using the <paramref name="packing" /> model and the character set defined by <paramref name="charSet" />.</returns>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.CreateFromStructure``1(``0)">
      <summary>Allocates from unmanaged memory sufficient memory to hold an object of type T.</summary>
      <param name="value">The value.</param>
      <typeparam name="T">Native type</typeparam>
      <returns>
        <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> object to an native (unmanaged) memory block the size of T.</returns>
    </member>
    <member name="P:Vanara.InteropServices.SafeLocalHandle.Null">
      <summary>Represents a NULL memory pointer.</summary>
    </member>
    <member name="M:Vanara.InteropServices.SafeLocalHandle.op_Implicit(System.IntPtr)~Vanara.InteropServices.SafeLocalHandle">
      <summary>Converts an <see cref="T:System.IntPtr" /> to a <see cref="T:Vanara.InteropServices.SafeLocalHandle" /> where it owns the reference.</summary>
      <param name="ptr">The <see cref="T:System.IntPtr" />.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ActivateActCtx(Vanara.PInvoke.Kernel32.ActCtxSafeHandle,System.IntPtr@)">
      <summary>
            The ActivateActCtx function activates the specified activation context. It does this by pushing the specified activation context to the top of the
            activation stack. The specified activation context is thus associated with the current thread and any appropriate side-by-side API functions.
            </summary>
      <param name="hActCtx">Handle to an ACTCTX structure that contains information on the activation context that is to be made active.</param>
      <param name="lpCookie">Pointer to a ULONG_PTR that functions as a cookie, uniquely identifying a specific, activated activation context.</param>
      <returns>If the function succeeds, it returns TRUE. Otherwise, it returns FALSE. This function sets errors that can be retrieved by calling GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ApplicationRecoveryFinished(System.Boolean)">
      <summary>Indicates that the calling application has completed its data recovery.</summary>
      <param name="bSuccess">Specify TRUE to indicate that the data was successfully recovered; otherwise, FALSE.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ApplicationRecoveryInProgress(System.Boolean@)">
      <summary>Indicates that the calling application is continuing to recover data.</summary>
      <param name="pbCanceled">Indicates whether the user has canceled the recovery process. Set by WER if the user clicks the Cancel button.</param>
      <returns>This function returns S_OK on success or one of the following error codes.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.BeginDeviceIoControl``2(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.Nullable{``0},System.Nullable{``1},System.AsyncCallback)">
      <summary>
            Starts the asynchronous operation of sending a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDevice">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="dwIoControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="inVal">A pointer to the input buffer that contains the data required to perform the operation. The format of this data depends on the value of the dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not require input data.</para></param>
      <param name="outVal">A pointer to the output buffer that is to receive the data returned by the operation. The format of this data depends on the value of the dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not return data.</para></param>
      <param name="userCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param>
      <typeparam name="TIn">The type of the <paramref name="inVal" />.</typeparam>
      <typeparam name="TOut">The type of the <paramref name="outVal" />.</typeparam>
      <returns>An IAsyncResult instance that references the asynchronous request.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.BeginReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte[],System.UInt32,System.AsyncCallback,System.Object)">
      <summary>
            Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
            </summary>
      <param name="hFile">A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe). The hFile parameter must have been created with read access. </param>
      <param name="buffer">A pointer to the buffer that receives the data read from a file or device.</param>
      <param name="numberOfBytesToRead">The maximum number of bytes to be read.</param>
      <param name="requestCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param>
      <param name="stateObject">A user-defined object that contains information about the operation. This object is passed to the requestCallback delegate when the operation is complete.</param>
      <returns>An IAsyncResult instance that references the asynchronous request.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.BeginWriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte[],System.UInt32,System.AsyncCallback,System.Object)">
      <summary>
            Writes data to the specified file or input/output (I/O) device.
            <para>This function is designed for both synchronous and asynchronous operation. For a similar function designed solely for asynchronous operation, see WriteFileEx.</para></summary>
      <param name="hFile">A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).
            <para>The hFile parameter must have been created with the write access. For more information, see Generic Access Rights and File Security and Access Rights.</para><para>For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.</para></param>
      <param name="buffer">A pointer to the buffer containing the data to be written to the file or device.
            <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para></param>
      <param name="numberOfBytesToWrite">The number of bytes to be written to the file or device.
            <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para><para>Windows Server 2003 and Windows XP:  Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para></param>
      <param name="requestCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param>
      <param name="stateObject">A user-defined object that contains information about the operation. This object is passed to the requestCallback delegate when the operation is complete.</param>
      <returns>An IAsyncResult instance that references the asynchronous request.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CloseHandle(System.IntPtr)">
      <summary>Closes an open object handle.</summary>
      <param name="hObject">A valid handle to an open object.</param>
      <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CreateActCtx(Vanara.PInvoke.Kernel32.ACTCTX@)">
      <summary>The CreateActCtx function creates an activation context.</summary>
      <param name="actctx">Pointer to an ACTCTX structure that contains information about the activation context to be created.</param>
      <returns>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CreateFile(System.String,Vanara.PInvoke.Kernel32.FileAccess,System.IO.FileShare,Vanara.PInvoke.SECURITY_ATTRIBUTES,System.IO.FileMode,Vanara.PInvoke.FileFlagsAndAttributes,Microsoft.Win32.SafeHandles.SafeFileHandle)">
      <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume,
            console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device
            for various types of I/O depending on the file or device and the flags and attributes specified.
            </summary>
      <param name="lpFileName">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            <para>
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, call the Unicode
            version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            </para><para>For information on special device names, see Defining an MS-DOS Device Name.</para><para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see File Streams.</para><note type="tip">Starting with Windows 10, version 1607, for the Unicode version of this function (CreateFileW), you can opt-in to remove the
            MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="dwDesiredAccess">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            <para>
            The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE). For more information, see Generic Access
            Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            </para><para>
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or
            device, even if GENERIC_READ access would have been denied.
            </para><para>
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already
            has an open handle.
            </para></param>
      <param name="dwShareMode">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table).
            Access requests to attributes or extended attributes are not affected by this flag.
            <para>
            If this parameter is zero and CreateFile succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or
            device is closed. For more information, see the Remarks section.
            </para><para>
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. CreateFile
            would fail and the GetLastError function would return ERROR_SHARING_VIOLATION.
            </para><para>
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the
            following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </para><note>The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</note></param>
      <param name="lpSecurityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean
            value that determines whether the returned handle can be inherited by child processes.
            <para>This parameter can be NULL.</para><para>
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or
            device associated with the returned handle gets a default security descriptor.
            </para><para>
            The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is NULL, the file or device
            associated with the returned handle is assigned a default security descriptor.
            </para><para>CreateFile ignores the lpSecurityDescriptor member when opening an existing file or device, but continues to use the bInheritHandle member.</para><para>The bInheritHandlemember of the structure specifies whether the returned handle can be inherited.</para></param>
      <param name="dwCreationDisposition">
            An action to take on a file or device that exists or does not exist.
            <para>For devices other than files, this parameter is usually set to OPEN_EXISTING.</para></param>
      <param name="dwFlagsAndAttributes">
            The file or device attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default value for files.
            <para>This parameter can include any combination of the available file attributes (FILE_ATTRIBUTE_*). All other file attributes override FILE_ATTRIBUTE_NORMAL.</para><para>
            This parameter can also contain combinations of flags (FILE_FLAG_*) for control of file or device caching behavior, access modes, and other
            special-purpose flags. These combine with any FILE_ATTRIBUTE_* values.
            </para><para>
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related
            flags information is presented in the table following the attributes and flags tables.
            </para><note>When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any
            file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.</note><para>
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open. For
            additional information, see the Remarks section of this topic and Creating and Opening Files.
            </para><para>
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions,
            see File Attribute Constants.
            </para></param>
      <param name="hTemplateFile">
            A valid handle to a template file with the GENERIC_READ access right. The template file supplies file attributes and extended attributes for the file
            that is being created.
            <para>This parameter can be NULL.</para><para>When opening an existing file, CreateFile ignores this parameter.</para><para>
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see
            File Encryption.
            </para></param>
      <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CreateFile(System.String,Vanara.PInvoke.Kernel32.FileAccess,System.IO.FileShare,Vanara.PInvoke.SECURITY_ATTRIBUTES,System.IO.FileMode,Vanara.PInvoke.FileFlagsAndAttributes,System.IntPtr)">
      <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume,
            console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device
            for various types of I/O depending on the file or device and the flags and attributes specified.
            </summary>
      <param name="lpFileName">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            <para>
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, call the Unicode
            version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            </para><para>For information on special device names, see Defining an MS-DOS Device Name.</para><para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see File Streams.</para><note type="tip">Starting with Windows 10, version 1607, for the Unicode version of this function (CreateFileW), you can opt-in to remove the
            MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="dwDesiredAccess">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            <para>
            The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE). For more information, see Generic Access
            Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            </para><para>
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or
            device, even if GENERIC_READ access would have been denied.
            </para><para>
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already
            has an open handle.
            </para></param>
      <param name="dwShareMode">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table).
            Access requests to attributes or extended attributes are not affected by this flag.
            <para>
            If this parameter is zero and CreateFile succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or
            device is closed. For more information, see the Remarks section.
            </para><para>
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. CreateFile
            would fail and the GetLastError function would return ERROR_SHARING_VIOLATION.
            </para><para>
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the
            following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </para><note>The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</note></param>
      <param name="lpSecurityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean
            value that determines whether the returned handle can be inherited by child processes.
            <para>This parameter can be NULL.</para><para>
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or
            device associated with the returned handle gets a default security descriptor.
            </para><para>
            The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is NULL, the file or device
            associated with the returned handle is assigned a default security descriptor.
            </para><para>CreateFile ignores the lpSecurityDescriptor member when opening an existing file or device, but continues to use the bInheritHandle member.</para><para>The bInheritHandlemember of the structure specifies whether the returned handle can be inherited.</para></param>
      <param name="dwCreationDisposition">
            An action to take on a file or device that exists or does not exist.
            <para>For devices other than files, this parameter is usually set to OPEN_EXISTING.</para></param>
      <param name="dwFlagsAndAttributes">
            The file or device attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default value for files.
            <para>This parameter can include any combination of the available file attributes (FILE_ATTRIBUTE_*). All other file attributes override FILE_ATTRIBUTE_NORMAL.</para><para>
            This parameter can also contain combinations of flags (FILE_FLAG_*) for control of file or device caching behavior, access modes, and other
            special-purpose flags. These combine with any FILE_ATTRIBUTE_* values.
            </para><para>
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related
            flags information is presented in the table following the attributes and flags tables.
            </para><note>When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any
            file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.</note><para>
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open. For
            additional information, see the Remarks section of this topic and Creating and Opening Files.
            </para><para>
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions,
            see File Attribute Constants.
            </para></param>
      <param name="hTemplateFile">
            A valid handle to a template file with the GENERIC_READ access right. The template file supplies file attributes and extended attributes for the file
            that is being created.
            <para>This parameter can be NULL.</para><para>When opening an existing file, CreateFile ignores this parameter.</para><para>
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see
            File Encryption.
            </para></param>
      <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CreateHardLink(System.String,System.String,System.IntPtr)">
      <summary>
            Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.
            </summary>
      <param name="lpFileName">The name of the new file.
            <para>This parameter may include the path but cannot specify the name of a directory.</para><para>In the ANSI version of this function, the name is limited to <c>MAX_PATH</c> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.</para><note><c>Tip</c> Starting with Windows 10, version 1607, for the Unicode version of this function (<c>CreateHardLinkW</c>), you can opt-in to remove the <c>MAX_PATH</c> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="lpExistingFileName">The name of the existing file.
            <para>This parameter may include the path but cannot specify the name of a directory.</para><para>In the ANSI version of this function, the name is limited to <c>MAX_PATH</c> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.</para><note><c>Tip</c> Starting with Windows 10, version 1607, for the Unicode version of this function (<c>CreateHardLinkW</c>), you can opt-in to remove the <c>MAX_PATH</c> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="lpSecurityAttributes">Reserved; must be NULL.</param>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.CreateHardLink(System.String,System.String,System.IntPtr)</parameter>
          </include>
        </markup>
      </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CreateSymbolicLink(System.String,System.String,Vanara.PInvoke.Kernel32.SymbolicLinkType)">
      <summary>
            Creates a symbolic link.
            </summary>
      <param name="lpSymlinkFileName">The symbolic link to be created.
            <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <c>MAX_PATH</c> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.</para><note><c>Tip</c> Starting with Windows 10, version 1607, for the Unicode version of this function (<c>CreateSymbolicLinkW</c>), you can opt-in to remove the <c>MAX_PATH</c> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="lpTargetFileName">The name of the target for the symbolic link to be created.
            <para>If lpTargetFileName has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para><para>This parameter may include the path. In the ANSI version of this function, the name is limited to <c>MAX_PATH</c> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.</para><note><c>Tip</c> Starting with Windows 10, version 1607, for the Unicode version of this function (<c>CreateSymbolicLinkW</c>), you can opt-in to remove the <c>MAX_PATH</c> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</note></param>
      <param name="dwFlags">Indicates whether the link target, lpTargetFileName, is a directory.</param>
      <returns>f the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CTL_CODE(System.UInt16,System.UInt16,System.Byte,System.Byte)">
      <summary>This macro is used to create a unique system I/O control code (IOCTL).</summary>
      <param name="deviceType">Defines the type of device for the given IOCTL. This parameter can be no bigger then a WORD value. The values used by Microsoft are in the range 0-32767 and the values 32768-65535 are reserved for use by OEMs and IHVs.</param>
      <param name="function">Defines an action within the device category. That function codes 0-2047 are reserved for Microsoft, and 2048-4095 are reserved for OEMs and IHVs. The function code can be no larger then 4095.</param>
      <param name="method">Defines the method codes for how buffers are passed for I/O and file system controls. The following list shows the possible values for this parameter:
            <list type="bullet"><item><description>METHOD_BUFFERED</description></item><item><description>METHOD_IN_DIRECT</description></item><item><description>METHOD_OUT_DIRECT</description></item><item><description>METHOD_NEITHER</description></item></list><para>This field is ignored under Windows CE and you should always use the METHOD_BUFFERED value unless compatibility with the desktop is required using a different Method value.</para></param>
      <param name="access">Defines the access check value for any access. The following table shows the possible flags for this parameter. The FILE_ACCESS_ANY is generally the correct value.
            <list type="table"><listheader><term>Flag</term><term>Description</term></listheader><item><term>FILE_ANY_ACCESS</term><term>Request all access.</term></item><item><term>FILE_READ_ACCESS</term><term>Request read access. Can be used with FILE_WRITE_ACCESS.</term></item><item><term>FILE_WRITE_ACCESS</term><term>Request write access. Can be used with FILE_READ_ACCESS.</term></item></list></param>
      <returns>The resulting I/O control code.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.CTL_CODE(Vanara.PInvoke.Kernel32.DEVICE_TYPE,System.UInt16,Vanara.PInvoke.Kernel32.IOMethod,Vanara.PInvoke.Kernel32.IOAccess)">
      <summary>This macro is used to create a unique system I/O control code (IOCTL).</summary>
      <param name="deviceType">Defines the type of device for the given IOCTL. This parameter can be no bigger then a WORD value. The values used by Microsoft are in the range 0-32767 and the values 32768-65535 are reserved for use by OEMs and IHVs.</param>
      <param name="function">Defines an action within the device category. That function codes 0-2047 are reserved for Microsoft, and 2048-4095 are reserved for OEMs and IHVs. The function code can be no larger then 4095.</param>
      <param name="method">Defines the method codes for how buffers are passed for I/O and file system controls.
            <para>This field is ignored under Windows CE and you should always use the METHOD_BUFFERED value unless compatibility with the desktop is required using a different Method value.</para></param>
      <param name="access">Defines the access check value for any access.</param>
      <returns>The resulting I/O control code.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeactivateActCtx(Vanara.PInvoke.Kernel32.DeactivateActCtxFlag,System.IntPtr)">
      <summary>The DeactivateActCtx function deactivates the activation context corresponding to the specified cookie.</summary>
      <param name="dwFlags">Flags that indicate how the deactivation is to occur.</param>
      <param name="lpCookie">
            The ULONG_PTR that was passed into the call to ActivateActCtx. This value is used as a cookie to identify a specific activated activation context.
            </param>
      <returns>If the function succeeds, it returns TRUE. Otherwise, it returns FALSE. This function sets errors that can be retrieved by calling GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControl(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.Byte*,System.UInt32,System.Byte*,System.UInt32,System.UInt32@,System.Threading.NativeOverlapped*)">
      <summary>Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.</summary>
      <param name="hDevice">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="dwIoControlCode">
            The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.
            </param>
      <param name="lpInBuffer">
            A pointer to the input buffer that contains the data required to perform the operation. The format of this data depends on the value of the
            dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not require input data.</para></param>
      <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
      <param name="lpOutBuffer">
            A pointer to the output buffer that is to receive the data returned by the operation. The format of this data depends on the value of the
            dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not return data.</para></param>
      <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
      <param name="lpBytesReturned">
            A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.
            <para>
            If the output buffer is too small to receive any data, the call fails, GetLastError returns ERROR_INSUFFICIENT_BUFFER, and lpBytesReturned is zero.
            </para><para>
            If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return as much data as fits. In this case, the
            call fails, GetLastError returns ERROR_MORE_DATA, and lpBytesReturned indicates the amount of data received. Your application should call
            DeviceIoControl again with the same operation, specifying a new starting point.
            </para><para>
            If lpOverlapped is NULL, lpBytesReturned cannot be NULL. Even when an operation returns no output data and lpOutBuffer is NULL, DeviceIoControl makes
            use of lpBytesReturned. After such an operation, the value of lpBytesReturned is meaningless.
            </para><para>
            If lpOverlapped is not NULL, lpBytesReturned can be NULL. If this parameter is not NULL and the operation returns data, lpBytesReturned is
            meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call GetOverlappedResult. If hDevice is
            associated with an I/O completion port, you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
            </para></param>
      <param name="lpOverlapped">
            A pointer to an OVERLAPPED structure.
            <para>If hDevice was opened without specifying FILE_FLAG_OVERLAPPED, lpOverlapped is ignored.</para><para>
            If hDevice was opened with the FILE_FLAG_OVERLAPPED flag, the operation is performed as an overlapped (asynchronous) operation. In this case,
            lpOverlapped must point to a valid OVERLAPPED structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways.
            </para><para>
            For overlapped operations, DeviceIoControl returns immediately, and the event object is signaled when the operation has been completed. Otherwise,
            the function does not return until the operation has been completed or an error occurs.
            </para></param>
      <returns>
            If the operation completes successfully, the return value is nonzero.
            <para>If the operation fails or is pending, the return value is zero. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControl(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr)">
      <summary>Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.</summary>
      <param name="hDevice">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="dwIoControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="lpInBuffer">A pointer to the input buffer that contains the data required to perform the operation. The format of this data depends on the value of the dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not require input data.</para></param>
      <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
      <param name="lpOutBuffer">A pointer to the output buffer that is to receive the data returned by the operation. The format of this data depends on the value of the dwIoControlCode parameter.
            <para>This parameter can be NULL if dwIoControlCode specifies an operation that does not return data.</para></param>
      <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
      <param name="lpBytesReturned">A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.
            <para>If the output buffer is too small to receive any data, the call fails, GetLastError returns ERROR_INSUFFICIENT_BUFFER, and lpBytesReturned is zero.</para><para>
            If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return as much data as fits. In this case, the
            call fails, GetLastError returns ERROR_MORE_DATA, and lpBytesReturned indicates the amount of data received. Your application should call
            DeviceIoControl again with the same operation, specifying a new starting point.
            </para><para>
            If lpOverlapped is NULL, lpBytesReturned cannot be NULL. Even when an operation returns no output data and lpOutBuffer is NULL, DeviceIoControl makes
            use of lpBytesReturned. After such an operation, the value of lpBytesReturned is meaningless.
            </para><para>
            If lpOverlapped is not NULL, lpBytesReturned can be NULL. If this parameter is not NULL and the operation returns data, lpBytesReturned is
            meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call GetOverlappedResult. If hDevice is
            associated with an I/O completion port, you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
            </para></param>
      <param name="lpOverlapped">
            A pointer to an OVERLAPPED structure.
            <para>If hDevice was opened without specifying FILE_FLAG_OVERLAPPED, lpOverlapped is ignored.</para><para>
            If hDevice was opened with the FILE_FLAG_OVERLAPPED flag, the operation is performed as an overlapped (asynchronous) operation. In this case,
            lpOverlapped must point to a valid OVERLAPPED structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways.
            </para><para>
            For overlapped operations, DeviceIoControl returns immediately, and the event object is signaled when the operation has been completed. Otherwise,
            the function does not return until the operation has been completed or an error occurs.
            </para></param>
      <returns>
            If the operation completes successfully, the return value is nonzero.
            <para>If the operation fails or is pending, the return value is zero. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControl``1(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,``0)">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDev">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="inVal">The data required to perform the operation. The format of this data depends on the value of the dwIoControlCode parameter.</param>
      <typeparam name="TIn">The type of the <paramref name="inVal" />.</typeparam>
      <returns>
        <c>true</c> if successful.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControl``2(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,``0,``1@)">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDev">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="inVal">The data required to perform the operation. The format of this data depends on the value of the dwIoControlCode parameter.</param>
      <param name="outVal">The data returned by the operation. The format of this data depends on the value of the dwIoControlCode parameter.</param>
      <typeparam name="TIn">The type of the <paramref name="inVal" />.</typeparam>
      <typeparam name="TOut">The type of the <paramref name="outVal" />.</typeparam>
      <returns>
        <c>true</c> if successful.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControl``1(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,``0@)">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDev">
            A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.
            </param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="outVal">The data returned by the operation. The format of this data depends on the value of the dwIoControlCode parameter.</param>
      <typeparam name="TOut">The type of the <paramref name="outVal" />.</typeparam>
      <returns>
        <c>true</c> if successful.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControlAsync``1(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32)">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDev">A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.</param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <typeparam name="TOut">The type of the return value.</typeparam>
      <returns>An asynchronous result containing the resulting value of type <typeparamref name="TOut" />.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControlAsync``2(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.Nullable{``0},System.Nullable{``1})">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDevice">A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.</param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="inVal">The input value required to perform the operation. The type of this data depends on the value of the <paramref name="ioControlCode" /> parameter.</param>
      <param name="outVal">The output value that is to receive the data returned by the operation. The type of this data depends on the value of the dwIoControlCode parameter.</param>
      <typeparam name="TIn">The type of the <paramref name="inVal" />.</typeparam>
      <typeparam name="TOut">The type of the <paramref name="outVal" />.</typeparam>
      <returns>An asynchronous result containing the populated data supplied by <paramref name="outVal" />.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.DeviceIoControlAsync``1(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,``0)">
      <summary>
            Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.
            </summary>
      <param name="hDev">A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device
            handle, use the CreateFile function. For more information, see Remarks.</param>
      <param name="ioControlCode">The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</param>
      <param name="inVal">The input value required to perform the operation. The type of this data depends on the value of the <paramref name="ioControlCode" /> parameter.</param>
      <typeparam name="TIn">The type of the <paramref name="inVal" />.</typeparam>
      <returns>An asynchronous empty result.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.EndDeviceIoControl``2(System.IAsyncResult)">
      <summary>
            Ends the asynchronous call to <see cref="M:Vanara.PInvoke.Kernel32.BeginDeviceIoControl``2(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.Nullable{``0},System.Nullable{``1},System.AsyncCallback)" />.
            </summary>
      <param name="asyncResult">The asynchronous result returned from <see cref="M:Vanara.PInvoke.Kernel32.BeginDeviceIoControl``2(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.Nullable{``0},System.Nullable{``1},System.AsyncCallback)" />.</param>
      <typeparam name="TIn">The type of the input value.</typeparam>
      <typeparam name="TOut">The type of the output value.</typeparam>
      <returns>The output value, if exists; <c>null</c> otherwise.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.EndReadFile(System.IAsyncResult)">
      <summary>Ends an asynchronous request for ReadFile.</summary>
      <param name="asyncResult">An IAsyncResult instance returned by a call to the BeginReadFile method.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.EndWriteFile(System.IAsyncResult)">
      <summary>Ends an asynchronous request for WriteFile.</summary>
      <param name="asyncResult">An IAsyncResult instance returned by a call to the BeginWriteFile method.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.EnumResourceNames(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.String,Vanara.PInvoke.Kernel32.EnumResNameProc,System.IntPtr)">
      <summary>
            Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a language-neutral Portable
            Executable (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that
            contain localizable language resources. It is also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
      <param name="hModule">
            A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in
            the search.
            <para>If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.</para></param>
      <param name="lpszType">
            The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where
            ID is an integer value representing a predefined resource type.
            </param>
      <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource name or ID.</param>
      <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
      <returns>
            The return value is TRUE if the function succeeds or FALSE if the function does not find a resource of the type specified, or if the function fails
            for another reason. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.EnumResourceNames(Vanara.PInvoke.Kernel32.SafeLibraryHandle,Vanara.PInvoke.SafeResourceId)">
      <summary>
            Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a language-neutral Portable
            Executable (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that
            contain localizable language resources. It is also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
      <param name="hModule">
            A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in
            the search.
            <para>If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.</para></param>
      <param name="type">
            The type of the resource for which the name is being enumerated. Alternately, rather than a string, this parameter can be MAKEINTRESOURCE(ID), where
            ID is an integer value representing a predefined resource type.
            </param>
      <returns>A list of strings for each of the resources matching <paramref name="type" />.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FileTimeToSystemTime(System.Runtime.InteropServices.ComTypes.FILETIME@,Vanara.PInvoke.SYSTEMTIME@)">
      <summary>Converts a file time to system time format. System time is based on Coordinated Universal Time (UTC).</summary>
      <param name="lpFileTime">
            A pointer to a FILETIME structure containing the file time to be converted to system (UTC) date and time format. This value must be less than
            0x8000000000000000. Otherwise, the function fails.
            </param>
      <param name="lpSystemTime">A pointer to a SYSTEMTIME structure to receive the converted file time.</param>
      <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FindResource(Vanara.PInvoke.Kernel32.SafeLibraryHandle,Vanara.PInvoke.SafeResourceId,Vanara.PInvoke.SafeResourceId)">
      <summary>
            Determines the location of a resource with the specified type and name in the specified module.
            <para>To specify a language, use the FindResourceEx function.</para></summary>
      <param name="hModule">
            A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is Null, the function
            searches the module used to create the current process.
            </param>
      <param name="lpName">
            The name of the resource. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE, where wInteger is the integer identifier of the resource.
            </param>
      <param name="lpType">
            The resource type. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE, where wInteger is the integer identifier of the given
            resource type.
            </param>
      <returns>
            If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this
            handle to the <see cref="M:Vanara.PInvoke.Kernel32.LoadResource(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)" /> function.
            <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FormatMessage(System.String,System.String[],Vanara.PInvoke.Kernel32.FormatMessageFlags)">
      <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a message table resource in an
            already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function
            finds the message definition in a message table resource based on a message identifier and a language identifier. The function returns the formatted
            message text, processing any embedded insert sequences if requested.
            </summary>
      <param name="formatString">Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.</param>
      <param name="args">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments
            array; a %2 indicates the second argument; and so on. The interpretation of each value depends on the formatting information associated with the
            insert in the message definition. Each insert must have a corresponding element in the array.
            </param>
      <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in
            the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
      <returns>
            If the function succeeds, the return value is the string that specifies the formatted message. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FormatMessage(System.UInt32,System.String[],Vanara.PInvoke.Kernel32.SafeLibraryHandle,Vanara.PInvoke.Kernel32.FormatMessageFlags,System.UInt32)">
      <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a message table resource in an
            already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function
            finds the message definition in a message table resource based on a message identifier and a language identifier. The function returns the formatted
            message text, processing any embedded insert sequences if requested.
            </summary>
      <param name="id">The message identifier for the requested message.</param>
      <param name="args">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments
            array; a %2 indicates the second argument; and so on. The interpretation of each value depends on the formatting information associated with the
            insert in the message definition. Each insert must have a corresponding element in the array.
            </param>
      <param name="hLib">A handle to the module that contains the message table to search.</param>
      <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in
            the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
      <param name="langId">
            The language identifier for the requested message. If you pass a specific LANGID in this parameter, FormatMessage will return a message for that
            LANGID only. If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,
            FormatMessage looks for a message for LANGIDs in the following order: Language neutral Thread LANGID, based on the thread's locale value User default
            LANGID, based on the user's default locale value System default LANGID, based on the system default locale value US English If FormatMessage does not
            locate a message for any of the preceding LANGIDs, it returns any language message string that is present. If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
      <returns>
            If the function succeeds, the return value is the string that specifies the formatted message. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FormatMessage(Vanara.PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr@,System.UInt32,System.String[])">
      <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the
            function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message
            table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and
            a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
      <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in
            the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
      <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags" /> parameter. If
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />: A handle to the module that contains the message table to search. If
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />: Pointer to a string that consists of unformatted message text. It will be scanned for
            inserts and formatted accordingly. If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
      <param name="dwMessageId">The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.</param>
      <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />. If you pass a specific LANGID in this parameter, FormatMessage will return a message for
            that LANGID only. If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,
            FormatMessage looks for a message for LANGIDs in the following order: Language neutral Thread LANGID, based on the thread's locale value User default
            LANGID, based on the user's default locale value System default LANGID, based on the system default locale value US English If FormatMessage does not
            locate a message for any of the preceding LANGIDs, it returns any language message string that is present. If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
      <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the
            pointer to the buffer at the address specified in lpBuffer. This buffer cannot be larger than 64K bytes.
            </param>
      <param name="nSize">
            If the <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" /> flag is not set, this parameter specifies the size of the output buffer, in
            TCHARs. If <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" /> is set, this parameter specifies the minimum number of TCHARs to allocate
            for an output buffer. The output buffer cannot be larger than 64K bytes.
            </param>
      <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments
            array; a %2 indicates the second argument; and so on. The interpretation of each value depends on the formatting information associated with the
            insert in the message definition.The default is to treat each value as a pointer to a null-terminated string. By default, the Arguments parameter is
            of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list
            argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and
            reinitialize it with va_start. If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer
            to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element
            in the array.
            </param>
      <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character. If the
            function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FormatMessage(Vanara.PInvoke.Kernel32.FormatMessageFlags,Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.UInt32,System.UInt32,System.IntPtr@,System.UInt32,System.String[])">
      <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the
            function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message
            table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and
            a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
      <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in
            the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
      <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags" /> parameter. If
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />: A handle to the module that contains the message table to search. If
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />: Pointer to a string that consists of unformatted message text. It will be scanned for
            inserts and formatted accordingly. If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
      <param name="dwMessageId">The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.</param>
      <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />. If you pass a specific LANGID in this parameter, FormatMessage will return a message for
            that LANGID only. If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,
            FormatMessage looks for a message for LANGIDs in the following order: Language neutral Thread LANGID, based on the thread's locale value User default
            LANGID, based on the user's default locale value System default LANGID, based on the system default locale value US English If FormatMessage does not
            locate a message for any of the preceding LANGIDs, it returns any language message string that is present. If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
      <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the
            pointer to the buffer at the address specified in lpBuffer. This buffer cannot be larger than 64K bytes.
            </param>
      <param name="nSize">
            If the <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" /> flag is not set, this parameter specifies the size of the output buffer, in
            TCHARs. If <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" /> is set, this parameter specifies the minimum number of TCHARs to allocate
            for an output buffer. The output buffer cannot be larger than 64K bytes.
            </param>
      <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments
            array; a %2 indicates the second argument; and so on. The interpretation of each value depends on the formatting information associated with the
            insert in the message definition.The default is to treat each value as a pointer to a null-terminated string. By default, the Arguments parameter is
            of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list
            argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and
            reinitialize it with va_start. If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer
            to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element
            in the array.
            </param>
      <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character. If the
            function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.FreeLibrary(System.IntPtr)">
      <summary>
            Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the reference count reaches zero, the
            module is unloaded from the address space of the calling process and the handle is no longer valid.
            </summary>
      <param name="hModule">
            A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or GetModuleHandleEx function returns this handle.
            </param>
      <returns>
            If the function succeeds, the return value is a nonzero value.
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetApplicationRecoveryCallback(System.IntPtr,Vanara.PInvoke.Kernel32.ApplicationRecoveryCallback@,System.IntPtr@,System.UInt32@,System.Int32@)">
      <summary>
            Retrieves a pointer to the callback routine registered for the specified process. The address returned is in the virtual address space of the process.
            </summary>
      <param name="hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
      <param name="pRecoveryCallback">A pointer to the recovery callback function. For more information, see ApplicationRecoveryCallback.</param>
      <param name="ppvParameter">A pointer to the callback parameter.</param>
      <param name="pdwPingInterval">The recovery ping interval, in 100-nanosecond intervals.</param>
      <param name="pdwFlags">Reserved for future use.</param>
      <returns>This function returns S_OK on success.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetApplicationRestartSettings(System.IntPtr,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.Kernel32.ApplicationRestartFlags@)">
      <summary>Retrieves the restart information registered for the specified process.</summary>
      <param name="hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
      <param name="pwzCommandline">
            A pointer to a buffer that receives the restart command line specified by the application when it called the RegisterApplicationRestart function. The
            maximum size of the command line, in characters, is RESTART_MAX_CMD_LINE. Can be NULL if pcchSize is zero.
            </param>
      <param name="pcchSize">
            On input, specifies the size of the pwzCommandLine buffer, in characters.
            <para>
            If the buffer is not large enough to receive the command line, the function fails with HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) and sets this
            parameter to the required buffer size, in characters.
            </para><para>On output, specifies the size of the buffer that was used.</para><para>
            To determine the required buffer size, set pwzCommandLine to NULL and this parameter to zero. The size includes one for the null-terminator
            character. Note that the function returns S_OK, not HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) in this case.
            </para></param>
      <param name="pdwFlags">
            A pointer to a variable that receives the flags specified by the application when it called the RegisterApplicationRestart function.
            </param>
      <returns>This function returns S_OK on success</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetCompressedFileSize(System.String,System.UInt32@)">
      <summary>
            Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and
            the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse
            files and the file is a sparse file, the value obtained is the sparse size of the specified file.
            </summary>
      <param name="lpFileName">
            The name of the file.
            <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para><para>
            This parameter may include the path. In the ANSI version of this function, the name is limited to <see cref="F:Vanara.PInvoke.Kernel32.MAX_PATH" /> characters. To extend this
            limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx">Naming a File</a>.
            </para><para><c>Tip</c> Starting with Windows 10, version 1607, for the Unicode version of this function ( <c>GetCompressedFileSizeW</c>), you can opt-in to
            remove the <see cref="F:Vanara.PInvoke.Kernel32.MAX_PATH" /> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx">Naming Files, Paths, and Namespaces</a> for details.
            </para></param>
      <param name="lpFileSizeHigh">
            The high-order DWORD of the compressed file size. The function's return value is the low-order DWORD of the compressed file size.
            <para>
            This parameter can be NULL if the high-order DWORD of the compressed file size is not needed.Files less than 4 gigabytes in size do not need the
            high-order DWORD.
            </para></param>
      <returns>
            If the function succeeds, the return value is the low-order DWORD of the actual number of bytes of disk storage used to store the specified file, and
            if <paramref name="lpFileSizeHigh" /> is non-NULL, the function puts the high-order DWORD of that actual value into the DWORD pointed to by that
            parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
            <para>
            If the function fails, and <paramref name="lpFileSizeHigh" /> is NULL, the return value is INVALID_FILE_SIZE. To get extended error information, call GetLastError.
            </para><para>
            If the return value is INVALID_FILE_SIZE and <paramref name="lpFileSizeHigh" /> is non-NULL, an application must call GetLastError to determine
            whether the function has succeeded (value is NO_ERROR) or failed (value is other than NO_ERROR).
            </para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetCurrentActCtx(Vanara.PInvoke.Kernel32.ActCtxSafeHandle@)">
      <summary>The GetCurrentActCtx function returns the handle to the active activation context of the calling thread.</summary>
      <param name="handle">Pointer to the returned ACTCTX structure that contains information on the active activation context.</param>
      <returns>If the function succeeds, it returns TRUE. Otherwise, it returns FALSE. This function sets errors that can be retrieved by calling GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetCurrentProcess">
      <summary>Retrieves a pseudo handle for the current process.</summary>
      <returns>The return value is a pseudo handle to the current process.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetCurrentThread">
      <summary>Retrieves a pseudo handle for the calling thread.</summary>
      <returns>The return value is a pseudo handle for the current thread.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetCurrentThreadId">
      <summary>Retrieves the thread identifier of the calling thread.</summary>
      <returns>The return value is the thread identifier of the calling thread.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetDiskFreeSpace(System.String,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
      <param name="lpRootPathName">
            The root directory of the disk for which information is to be returned. If this parameter is NULL, the function uses the root of the current disk. If
            this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have
            a trailing backslash (for example, "C:\"). The calling application must have FILE_LIST_DIRECTORY access rights for this directory.
            </param>
      <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
      <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
      <param name="lpNumberOfFreeClusters">
            A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.
            <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para></param>
      <param name="lpTotalNumberOfClusters">
            A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.
            <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para></param>
      <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetDiskFreeSpaceEx(System.String,System.UInt64@,System.UInt64@,System.UInt64@)">
      <summary>
            Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free
            space, and the total amount of free space available to the user that is associated with the calling thread.
            </summary>
      <param name="lpDirectoryName">
            A directory on the disk.
            <para>If this parameter is NULL, the function uses the root of the current disk.</para><para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para><para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para><para>The calling application must have FILE_LIST_DIRECTORY access rights for this directory.</para></param>
      <param name="lpFreeBytesAvailable">
            A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.
            <para>This parameter can be NULL.</para><para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para></param>
      <param name="lpTotalNumberOfBytes">
            A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.
            <para>This parameter can be NULL.</para><para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para><para>To determine the total number of bytes on a disk or volume, use IOCTL_DISK_GET_LENGTH_INFO.</para></param>
      <param name="lpTotalNumberOfFreeBytes">
            A pointer to a variable that receives the total number of free bytes on a disk.
            <para>This parameter can be NULL.</para></param>
      <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetModuleFileName(Vanara.PInvoke.Kernel32.SafeLibraryHandle)">
      <summary>
            Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.
            <para>To locate the file for a module that was loaded by another process, use the GetModuleFileNameEx function.</para></summary>
      <param name="hModule">
            A handle to the loaded module whose path is being requested. If this parameter is NULL, GetModuleFileName retrieves the path of the executable file
            of the current process.
            <para>
            The GetModuleFileName function does not retrieve the path for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information,
            see LoadLibraryEx.
            </para></param>
      <returns>
            The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and
            can use the prefix "\\?\". For more information, see Naming a File.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetModuleFileName(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.Text.StringBuilder,System.Int32)">
      <summary>
            Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.
            <para>To locate the file for a module that was loaded by another process, use the GetModuleFileNameEx function.</para></summary>
      <param name="hModule">
            A handle to the loaded module whose path is being requested. If this parameter is NULL, GetModuleFileName retrieves the path of the executable file
            of the current process.
            <para>
            The GetModuleFileName function does not retrieve the path for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information,
            see LoadLibraryEx.
            </para></param>
      <param name="lpFilename">
            A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the nSize parameter
            specifies, the function succeeds and the path is returned as a null-terminated string.
            <para>
            If the length of the path exceeds the size that the nSize parameter specifies, the function succeeds and the string is truncated to nSize characters
            including the terminating null character.
            </para><para><c>Windows XP:</c> The string is truncated to nSize characters and is not null-terminated.</para><para>
            The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and
            can use the prefix "\\?\". For more information, see Naming a File.
            </para></param>
      <param name="nSize">The size of the lpFilename buffer, in TCHARs.</param>
      <returns>
            If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating
            null character. If the buffer is too small to hold the module name, the string is truncated to nSize characters including the terminating null
            character, the function returns nSize, and the function sets the last error to ERROR_INSUFFICIENT_BUFFER.
            <para><c>Windows XP:</c> If the buffer is too small to hold the module name, the function returns nSize. The last error code remains ERROR_SUCCESS. If
            nSize is zero, the return value is zero and the last error code is ERROR_SUCCESS.
            </para><para>If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetProcAddress(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.String)">
      <summary>The GetProcAddress function retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
      <param name="hModule">
            Handle to the DLL module that contains the function or variable. The LoadLibrary or GetModuleHandle function returns this handle.
            </param>
      <param name="lpProcName">
            Pointer to a null-terminated string containing the function or variable name, or the function's ordinal value. If this parameter is an ordinal value,
            it must be in the low-order word; the high-order word must be zero.
            </param>
      <returns>
            If the function succeeds, the return value is the address of the exported function or variable. <br></br><br>If the function fails, the return value
            is NULL. To get extended error information, call Marshal.GetLastWin32Error.</br></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetProcessHeap">
      <summary>Retrieves a handle to the default heap of the calling process. This handle can then be used in subsequent calls to the heap functions.</summary>
      <returns>If the function succeeds, the return value is a handle to the calling process's heap. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetVolumeInformation(System.String,System.String@,System.UInt32@,System.UInt32@,Vanara.PInvoke.Kernel32.FileSystemFlags@,System.String@)">
      <summary>Retrieves information about the file system and volume associated with the specified root directory.</summary>
      <param name="rootPathName">
            A string that contains the root directory of the volume to be described.
            <para>
            If this parameter is NULL, the root of the current directory is used. A trailing backslash is required. For example, you specify \\MyServer\MyShare
            as "\\MyServer\MyShare\", or the C drive as "C:\".
            </para></param>
      <param name="volumeName">Receives the name of a specified volume.</param>
      <param name="volumeSerialNumber">
            Receives the volume serial number.
            <para>
            This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard
            disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property SerialNumber.
            </para></param>
      <param name="maximumComponentLength">
            Receives the maximum length, in characters, of a file name component that a specified file system supports.
            <para>A file name component is the portion of a file name between backslashes.</para><para>
            The value that is stored in the variable that <paramref name="maximumComponentLength" /> returns is used to indicate that a specified file system
            supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3
            indicator. Long names can also be supported on systems that use the NTFS file system.
            </para></param>
      <param name="fileSystemFlags">
            Receives the flags associated with the specified file system.
            <para>
            This parameter can be one or more of the <see cref="T:Vanara.PInvoke.Kernel32.FileSystemFlags" /> values. However, FILE_FILE_COMPRESSION and FILE_VOL_IS_COMPRESSED are mutually exclusive.
            </para></param>
      <param name="fileSystemName">Receives the name of the file system, for example, the FAT file system or the NTFS file system.</param>
      <returns>
            If all the requested information is retrieved, the return value is nonzero.
            <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GetVolumeInformation(System.String,System.Text.StringBuilder,System.Int32,System.UInt32@,System.UInt32@,Vanara.PInvoke.Kernel32.FileSystemFlags@,System.Text.StringBuilder,System.Int32)">
      <summary>Retrieves information about the file system and volume associated with the specified root directory.</summary>
      <param name="lpRootPathName">
            A pointer to a string that contains the root directory of the volume to be described.
            <para>
            If this parameter is NULL, the root of the current directory is used. A trailing backslash is required. For example, you specify \\MyServer\MyShare
            as "\\MyServer\MyShare\", or the C drive as "C:\".
            </para></param>
      <param name="lpVolumeNameBuffer">
            A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <paramref name="nVolumeNameSize" /> parameter.
            </param>
      <param name="nVolumeNameSize">
            The length of a volume name buffer, in TCHARs. The maximum buffer size is MAX_PATH+1.
            <para>This parameter is ignored if the volume name buffer is not supplied.</para></param>
      <param name="lpVolumeSerialNumber">
            A pointer to a variable that receives the volume serial number.
            <para>This parameter can be NULL if the serial number is not required.</para><para>
            This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard
            disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property SerialNumber.
            </para></param>
      <param name="lpMaximumComponentLength">
            A pointer to a variable that receives the maximum length, in TCHARs, of a file name component that a specified file system supports.
            <para>A file name component is the portion of a file name between backslashes.</para><para>
            The value that is stored in the variable that <paramref name="lpMaximumComponentLength" /> points to is used to indicate that a specified file system
            supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3
            indicator. Long names can also be supported on systems that use the NTFS file system.
            </para></param>
      <param name="lpFileSystemFlags">
            A pointer to a variable that receives flags associated with the specified file system.
            <para>
            This parameter can be one or more of the <see cref="T:Vanara.PInvoke.Kernel32.FileSystemFlags" /> values. However, FILE_FILE_COMPRESSION and FILE_VOL_IS_COMPRESSED are mutually exclusive.
            </para></param>
      <param name="lpFileSystemNameBuffer">
            A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is
            specified by the <paramref name="nFileSystemNameSize" /> parameter.
            </param>
      <param name="nFileSystemNameSize">
            The length of the file system name buffer, in TCHARs. The maximum buffer size is MAX_PATH+1.
            <para>This parameter is ignored if the file system name buffer is not supplied.</para></param>
      <returns>
            If all the requested information is retrieved, the return value is nonzero.
            <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GlobalLock(System.IntPtr)">
      <summary>
            The GlobalLock function locks a global memory object and returns a pointer to the first byte of the object's memory block. GlobalLock function
            increments the lock count by one. Needed for the clipboard functions when getting the data from IDataObject
            </summary>
      <param name="hMem">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>hMem</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.GlobalLock(System.IntPtr)</parameter>
          </include>
        </markup>
      </param>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.GlobalLock(System.IntPtr)</parameter>
          </include>
        </markup>
      </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.GlobalUnlock(System.IntPtr)">
      <summary>The GlobalUnlock function decrements the lock count associated with a memory object.</summary>
      <param name="hMem">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>hMem</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.GlobalUnlock(System.IntPtr)</parameter>
          </include>
        </markup>
      </param>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.GlobalUnlock(System.IntPtr)</parameter>
          </include>
        </markup>
      </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.HeapAlloc(System.IntPtr,Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr)">
      <summary>Allocates a block of memory from a heap. The allocated memory is not movable.</summary>
      <param name="hHeap">A handle to the heap from which the memory will be allocated. This handle is returned by the HeapCreate or GetProcessHeap function.</param>
      <param name="dwFlags">The heap allocation options. Specifying any of these values will override the corresponding value specified when the heap was created with HeapCreate. This parameter can be one or more of the following values: HEAP_GENERATE_EXCEPTIONS, HEAP_NO_SERIALIZE and HEAP_ZERO_MEMORY.</param>
      <param name="dwBytes">The number of bytes to be allocated. If the heap specified by the hHeap parameter is a "non-growable" heap, dwBytes must be less than 0x7FFF8. You create a non-growable heap by calling the HeapCreate function with a nonzero value.</param>
      <returns>If the function succeeds, the return value is a pointer to the allocated memory block.
            <para>If the function fails and you have not specified HEAP_GENERATE_EXCEPTIONS, the return value is NULL.</para><para>If the function fails and you have specified HEAP_GENERATE_EXCEPTIONS, the function may generate either of the exceptions listed in the following table. The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.HeapCreate(Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr,System.IntPtr)">
      <summary>Creates a private heap object that can be used by the calling process. The function reserves space in the virtual address space of the process and allocates physical storage for a specified initial portion of this block.</summary>
      <param name="flOptions">The heap allocation options. These options affect subsequent access to the new heap through calls to the heap functions. This parameter can be 0 or one or more of the following values: HEAP_CREATE_ENABLE_EXECUTE, HEAP_GENERATE_EXCEPTIONS, HEAP_NO_SERIALIZE.</param>
      <param name="dwInitialSize">The initial size of the heap, in bytes. This value determines the initial amount of memory that is committed for the heap. The value is rounded up to a multiple of the system page size. The value must be smaller than dwMaximumSize.
            <para>If this parameter is 0, the function commits one page. To determine the size of a page on the host computer, use the GetSystemInfo function.</para></param>
      <param name="dwMaximumSize">The maximum size of the heap, in bytes. The HeapCreate function rounds dwMaximumSize up to a multiple of the system page size and then reserves a block of that size in the process's virtual address space for the heap. If allocation requests made by the HeapAlloc or HeapReAlloc functions exceed the size specified by dwInitialSize, the system commits additional pages of memory for the heap, up to the heap's maximum size.
            <para>If dwMaximumSize is not zero, the heap size is fixed and cannot grow beyond the maximum size. Also, the largest memory block that can be allocated from the heap is slightly less than 512 KB for a 32-bit process and slightly less than 1,024 KB for a 64-bit process. Requests to allocate larger blocks fail, even if the maximum size of the heap is large enough to contain the block.</para><para>If dwMaximumSize is 0, the heap can grow in size. The heap's size is limited only by the available memory. Requests to allocate memory blocks larger than the limit for a fixed-size heap do not automatically fail; instead, the system calls the VirtualAlloc function to obtain the memory that is needed for large blocks. Applications that need to allocate large memory blocks should set dwMaximumSize to 0.</para></param>
      <returns>If the function succeeds, the return value is a handle to the newly created heap. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.HeapDestroy(System.IntPtr)">
      <summary>Destroys the specified heap object. It decommits and releases all the pages of a private heap object, and it invalidates the handle to the heap.</summary>
      <param name="hHeap">A handle to the heap to be destroyed. This handle is returned by the HeapCreate function. Do not use the handle to the process heap returned by the GetProcessHeap function.</param>
      <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.HeapFree(System.IntPtr,Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr)">
      <summary>Frees a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.</summary>
      <param name="hHeap">A handle to the heap whose memory block is to be freed. This handle is returned by either the HeapCreate or GetProcessHeap function.</param>
      <param name="dwFlags">The heap free options. Specifying the following value overrides the corresponding value specified in the flOptions parameter when the heap was created by using the HeapCreate function: HEAP_NO_SERIALIZE</param>
      <param name="lpMem">A pointer to the memory block to be freed. This pointer is returned by the HeapAlloc or HeapReAlloc function. If this pointer is NULL, the behavior is undefined.</param>
      <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.An application can call GetLastError for extended error information.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.HeapSize(System.IntPtr,Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr)">
      <summary>Retrieves the size of a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.</summary>
      <param name="hHeap">A handle to the heap in which the memory block resides. This handle is returned by either the HeapCreate or GetProcessHeap function.</param>
      <param name="dwFlags">The heap size options. Specifying the following value overrides the corresponding value specified in the flOptions parameter when the heap was created by using the HeapCreate function.</param>
      <param name="lpMem">A pointer to the memory block whose size the function will obtain. This is a pointer returned by the HeapAlloc or HeapReAlloc function. The memory block must be from the heap specified by the hHeap parameter.</param>
      <returns>If the function succeeds, the return value is the requested size of the allocated memory block, in bytes.
            <para>If the function fails, the return value is (SIZE_T)-1. The function does not call SetLastError. An application cannot call GetLastError for extended error information.</para><para>If the lpMem parameter refers to a heap allocation that is not in the heap specified by the hHeap parameter, the behavior of the HeapSize function is undefined.</para></returns>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.INVALID_FILE_ATTRIBUTES">
      <summary>A value returned when invalid file attributes are found.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.INVALID_FILE_SIZE">
      <summary>A value returned by <see cref="M:Vanara.PInvoke.Kernel32.GetCompressedFileSize(System.String,System.UInt32@)" /> when the function fails.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.INVALID_SET_FILE_POINTER">
      <summary>A value returned then a file pointer cannot be set.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LoadLibrary(System.String)">
      <summary>
            Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.
            <para>For additional load options, use the LoadLibraryEx function.</para></summary>
      <param name="lpFileName">
            The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). The name specified is the file name
            of the module and is not related to the name stored in the library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
            <para>If the string specifies a full path, the function searches only that path for the module.</para><para>If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module.</para><para>If the function cannot find the module, the function fails. When specifying a path, be sure to use backslashes (\), not forward slashes (/).</para><para>
            If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll
            to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.
            </para></param>
      <returns>
            If the function succeeds, the return value is a handle to the loaded module.
            <para>If the function fails, the return value is an invalid handle. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,Vanara.PInvoke.Kernel32.LoadLibraryExFlags)">
      <summary>Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.</summary>
      <param name="lpFileName">
        <para>
            A string that specifies the file name of the module to load. This name is not related to the name stored in a library module itself, as specified by
            the LIBRARY keyword in the module-definition (.def) file.
            </para>
        <para>
            The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static
            imports are not loaded; instead, the module is loaded as if <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES" /> was specified. See the
            <paramref name="dwFlags" /> parameter for more information.
            </para>
        <para>
            If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll
            to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.
            </para>
        <para>
            If the string specifies a fully qualified path, the function searches only that path for the module. When specifying a path, be sure to use
            backslashes (\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces.
            </para>
        <para>
            If the string specifies a module name without a path and more than one loaded module has the same base name and extension, the function returns a
            handle to the module that was loaded first.
            </para>
        <para>
            If the string specifies a module name without a path and a module of the same name is not already loaded, or if the string specifies a module name
            with a relative path, the function searches for the specified module. The function also searches for modules if loading the specified module causes
            the system to load other associated modules (that is, if the module has dependencies). The directories that are searched and the order in which they
            are searched depend on the specified path and the dwFlags parameter.
            </para>
        <para>If the function cannot find the module or one of its dependencies, the function fails.</para>
      </param>
      <param name="hFile">This parameter is reserved for future use. It must be <see langword="null" />.</param>
      <param name="dwFlags">
            The action to be taken when loading the module. If <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.None" /> is specified, the behavior of this function is identical to
            that of the LoadLibrary function.
            </param>
      <returns>
            If the function succeeds, the return value is a handle to the loaded module.
            <para>If the function fails, the return value is an invalid handle. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LoadResource(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
      <summary>Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.</summary>
      <param name="hModule">
            A handle to the module whose executable file contains the resource. If hModule is <see cref="P:Vanara.PInvoke.Kernel32.SafeLibraryHandle.Null" />, the system loads the resource
            from the module that was used to create the current process.
            </param>
      <param name="hResInfo">A handle to the resource to be loaded. This handle is returned by the FindResource or FindResourceEx function.</param>
      <returns>
            If the function succeeds, the return value is a handle to the data associated with the resource.
            <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LocalAlloc(Vanara.PInvoke.Kernel32.LocalMemoryFlags,System.UIntPtr)">
      <summary>
            Allocates the specified number of bytes from the heap. <note>The local functions have greater overhead and provide fewer features than other memory
            management functions. New applications should use the heap functions unless documentation states that a local function should be used. For more
            information, see Global and Local Functions.</note></summary>
      <param name="uFlags">
            The memory allocation attributes. The default is the LMEM_FIXED value. This parameter can be one or more of the following values, except for the
            incompatible combinations that are specifically noted.
            <list type="table"><listheader><term>Value</term><term>Meaning</term></listheader><item><term><c>LHND</c><para>0x0042</para></term><term>Combines LMEM_MOVEABLE and LMEM_ZEROINIT.</term></item><item><term><c>LMEM_FIXED</c><para>0x0000</para></term><term>Allocates fixed memory. The return value is a pointer to the memory object.</term></item><item><term><c>LMEM_MOVEABLE</c><para>0x0002</para></term><term>
            Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap.
            <para>The return value is a handle to the memory object. To translate the handle to a pointer, use the LocalLock function.</para><para>This value cannot be combined with LMEM_FIXED.</para></term></item><item><term><c>LMEM_ZEROINIT</c><para>0x0040</para></term><term>Initializes memory contents to zero.</term></item><item><term><c>LPTR</c><para>0x0040</para></term><term>Combines LMEM_FIXED and LMEM_ZEROINIT.</term></item><item><term><c>NONZEROLHND</c></term><term>Same as LMEM_MOVEABLE.</term></item><item><term><c>NONZEROLPTR</c></term><term>Same as LMEM_FIXED.</term></item></list><para>The following values are obsolete, but are provided for compatibility with 16-bit Windows. They are ignored.</para><list type="bullet"><item><term>LMEM_DISCARDABLE</term></item><item><term>LMEM_NOCOMPACT</term></item><item><term>LMEM_NODISCARD</term></item></list></param>
      <param name="uBytes">
            The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies LMEM_MOVEABLE, the function returns a handle to a
            memory object that is marked as discarded.
            </param>
      <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object. If the function fails, the return value is NULL. To get
            extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LocalFree(System.IntPtr)">
      <summary>
            Frees the specified local memory object and invalidates its handle. <note>The local functions have greater overhead and provide fewer features than
            other memory management functions. New applications should use the heap functions unless documentation states that a local function should be used.
            For more information, see Global and Local Functions.</note></summary>
      <param name="hMem">
            A handle to the local memory object. This handle is returned by either the LocalAlloc or LocalReAlloc function. It is not safe to free memory
            allocated with GlobalAlloc.
            </param>
      <returns>
            If the function succeeds, the return value is NULL. If the function fails, the return value is equal to a handle to the local memory object. To get
            extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LocalReAlloc(System.IntPtr,System.UIntPtr,Vanara.PInvoke.Kernel32.LocalMemoryFlags)">
      <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease. <note>The local functions have greater
            overhead and provide fewer features than other memory management functions. New applications should use the heap functions unless documentation
            states that a local function should be used. For more information, see Global and Local Functions.</note></summary>
      <param name="hMem">A handle to the local memory object to be reallocated. This handle is returned by either the LocalAlloc or LocalReAlloc function.</param>
      <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies LMEM_MODIFY, this parameter is ignored.</param>
      <param name="uFlags">
            The reallocation options. If LMEM_MODIFY is specified, the function modifies the attributes of the memory object only (the uBytes parameter is
            ignored.) Otherwise, the function reallocates the memory object.
            <para>You can optionally combine LMEM_MODIFY with the following value.</para><list type="table"><listheader><term>Value</term><term>Meaning</term></listheader><item><term><c>LMEM_MOVEABLE</c><para>0x0002</para></term><term>
            Allocates fixed or movable memory.
            <para>
            If the memory is a locked LMEM_MOVEABLE memory block or a LMEM_FIXED memory block and this flag is not specified, the memory can only be reallocated
            in place.
            </para></term></item></list><para>
            If the memory is a locked LMEM_MOVEABLE memory block or a LMEM_FIXED memory block and this flag is not specified, the memory can only be reallocated
            in place.
            </para><para>If this parameter does not specify LMEM_MODIFY, you can use the following value.</para><list type="table"><listheader><term>Value</term><term>Meaning</term></listheader><item><term><c>LMEM_ZEROINIT</c><para>0x0040</para></term><term>Causes the additional memory contents to be initialized to zero if the memory object is growing in size.</term></item></list></param>
      <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails, the return value is NULL. To get
            extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LocalSize(System.IntPtr)">
      <summary>
            Retrieves the current size of the specified local memory object, in bytes. <note>The local functions have greater overhead and provide fewer features
            than other memory management functions. New applications should use the heap functions unless documentation states that a local function should be
            used. For more information, see Global and Local Functions.</note></summary>
      <param name="hMem">A handle to the local memory object. This handle is returned by the LocalAlloc, LocalReAlloc, or LocalHandle function.</param>
      <returns>
            If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the specified handle is not valid or if the
            object has been discarded, the return value is zero. To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.LockResource(System.IntPtr)">
      <summary>Retrieves a pointer to the specified resource in memory.</summary>
      <param name="hResData">A handle to the resource to be accessed. The <see cref="M:Vanara.PInvoke.Kernel32.LoadResource(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)" /> function returns this handle.</param>
      <returns>If the loaded resource is available, the return value is a pointer to the first byte of the resource; otherwise, it is NULL.</returns>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.MAX_PATH">
      <summary>The maximum character length for a path.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.QueryDosDevice(System.String)">
      <summary>
            Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can
            also obtain a list of all existing MS-DOS device names.
            <para>
            MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these
            junctions to map MS-DOS devices and drive letters. The QueryDosDevice function enables an application to query the names of the junctions used to
            implement the MS-DOS device namespace as well as the value of each specific junction.
            </para></summary>
      <param name="deviceName">
            An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".
            <para>This parameter can be NULL. In that case, the QueryDosDevice function will return a list of all existing MS-DOS device names.</para></param>
      <returns>
        <para>
            If <paramref name="deviceName" /> is non-NULL, the function returns information about the particular MS-DOS device specified by <paramref name="deviceName" />. The first string returned is the current mapping for the device. The other strings represent undeleted prior mappings for the device.
            </para>
        <para>
            If <paramref name="deviceName" /> is NULL, the function returns a list of all existing MS-DOS device names. Each string returned is the name of an
            existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
            </para>
      </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.QueryDosDevice(System.String,System.Text.StringBuilder,System.Int32)">
      <summary>
            Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can
            also obtain a list of all existing MS-DOS device names.
            <para>
            MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these
            junctions to map MS-DOS devices and drive letters. The QueryDosDevice function enables an application to query the names of the junctions used to
            implement the MS-DOS device namespace as well as the value of each specific junction.
            </para></summary>
      <param name="lpDeviceName">
            An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".
            <para>
            This parameter can be NULL. In that case, the QueryDosDevice function will store a list of all existing MS-DOS device names into the buffer pointed
            to by <paramref name="lpTargetPath" />.
            </para></param>
      <param name="lpTargetPath">
            A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final
            null-terminated string is followed by an additional NULL.
            <para>
            If <paramref name="lpDeviceName" /> is non-NULL, the function retrieves information about the particular MS-DOS device specified by <paramref name="lpDeviceName" />. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
            strings represent undeleted prior mappings for the device.
            </para><para>
            If <paramref name="lpDeviceName" /> is NULL, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored
            into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
            </para></param>
      <param name="ucchMax">The maximum number of TCHARs that can be stored into the buffer pointed to by <paramref name="lpTargetPath" />.</param>
      <returns>
            If the function succeeds, the return value is the number of TCHARs stored into the buffer pointed to by <paramref name="lpTargetPath" />.
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para><para>If the buffer is too small, the function fails and the last error code is ERROR_INSUFFICIENT_BUFFER.</para></returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.UInt32,System.IntPtr,System.Threading.NativeOverlapped*)">
      <summary>
            Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
            </summary>
      <param name="hFile">A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe). The hFile parameter must have been created with read access. </param>
      <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
      <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
      <param name="lpNumberOfBytesRead">A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise it can be NULL.
            <para>If hFile is opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must point to a valid and unique OVERLAPPED structure, otherwise the function can incorrectly report that the read operation is complete.</para><para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte[],System.UInt32,System.UInt32@,System.IntPtr)">
      <summary>
            Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
            </summary>
      <param name="hFile">A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe). The hFile parameter must have been created with read access. </param>
      <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
      <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
      <param name="lpNumberOfBytesRead">A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise it can be NULL.
            <para>If hFile is opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must point to a valid and unique OVERLAPPED structure, otherwise the function can incorrectly report that the read operation is complete.</para><para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr)">
      <summary>
            Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
            </summary>
      <param name="hFile">A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe). The hFile parameter must have been created with read access. </param>
      <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
      <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
      <param name="lpNumberOfBytesRead">A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise it can be NULL.
            <para>If hFile is opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must point to a valid and unique OVERLAPPED structure, otherwise the function can incorrectly report that the read operation is complete.</para><para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.RegisterApplicationRecoveryCallback(Vanara.PInvoke.Kernel32.ApplicationRecoveryCallback,System.IntPtr,System.UInt32,System.UInt32)">
      <summary>Registers the active instance of an application for recovery.</summary>
      <param name="pRecoveryCallback">A pointer to the recovery callback function. For more information, see ApplicationRecoveryCallback.</param>
      <param name="pvParameter">A pointer to a variable to be passed to the callback function. Can be NULL.</param>
      <param name="dwPingInterval">
            The recovery ping interval, in milliseconds. By default, the interval is 5 seconds (RECOVERY_DEFAULT_PING_INTERVAL). The maximum interval is 5
            minutes. If you specify zero, the default interval is used.
            <para>
            You must call the ApplicationRecoveryInProgress function within the specified interval to indicate to ARR that you are still actively recovering;
            otherwise, WER terminates recovery. Typically, you perform recovery in a loop with each iteration lasting no longer than the ping interval. Each
            iteration performs a block of recovery work followed by a call to ApplicationRecoveryInProgress. Since you also use ApplicationRecoveryInProgress to
            determine if the user wants to cancel recovery, you should consider a smaller interval, so you do not perform a lot of work unnecessarily.
            </para></param>
      <param name="dwFlags">Reserved for future use. Set to zero.</param>
      <returns>This function returns S_OK on success</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.RegisterApplicationRestart(System.String,Vanara.PInvoke.Kernel32.ApplicationRestartFlags)">
      <summary>Registers the active instance of an application for restart.</summary>
      <param name="pwzCommandline">
            A string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can
            specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you.
            <para>
            If this parameter is NULL or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around
            the argument.
            </para></param>
      <param name="dwFlags">Options</param>
      <returns>This function returns S_OK on success</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ReleaseActCtx(System.IntPtr)">
      <summary>The ReleaseActCtx function decrements the reference count of the specified activation context.</summary>
      <param name="hActCtx">
            Handle to the ACTCTX structure that contains information on the activation context for which the reference count is to be decremented.
            </param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SetFilePointerEx(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64,System.Int64@,System.IO.SeekOrigin)">
      <summary>Moves the file pointer of the specified file.</summary>
      <param name="hFile">A handle to the file. The file handle must have been created with the GENERIC_READ or GENERIC_WRITE access right. For more information, see File Security and Access Rights.</param>
      <param name="liDistanceToMove">The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a negative value moves the file pointer backward.</param>
      <param name="lpNewFilePointer">A pointer to a variable to receive the new file pointer. If this parameter is NULL, the new file pointer is not returned.</param>
      <param name="dwMoveMethod">The starting point for the file pointer move.</param>
      <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SetLastError(System.UInt32)">
      <summary>Sets the last-error code for the calling thread.</summary>
      <param name="dwErrCode">The last-error code for the thread.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SizeofResource(Vanara.PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
      <summary>Retrieves the size, in bytes, of the specified resource.</summary>
      <param name="hModule">A handle to the module whose executable file contains the resource.</param>
      <param name="hResInfo">A handle to the resource. This handle must be created by using the FindResource or FindResourceEx function.</param>
      <returns>
            If the function succeeds, the return value is the number of bytes in the resource. If the function fails, the return value is zero. To get extended
            error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SystemTimeToFileTime(Vanara.PInvoke.SYSTEMTIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
      <summary>Converts a system time to file time format. System time is based on Coordinated Universal Time (UTC).</summary>
      <param name="lpSystemTime">
            A pointer to a SYSTEMTIME structure that contains the system time to be converted from UTC to file time format. The wDayOfWeek member of the
            SYSTEMTIME structure is ignored.
            </param>
      <param name="lpFileTime">A pointer to a FILETIME structure to receive the converted system time.</param>
      <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ToFILETIME(Vanara.PInvoke.SYSTEMTIME)">
      <summary>Convert a <see cref="T:Vanara.PInvoke.SYSTEMTIME" /> value to a <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME" /> value.</summary>
      <param name="st">The <see cref="T:Vanara.PInvoke.SYSTEMTIME" /> value.</param>
      <returns>The converted <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME" /> value.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ToSYSTEMTIME(System.Runtime.InteropServices.ComTypes.FILETIME)">
      <summary>Convert a <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME" /> value to a <see cref="T:Vanara.PInvoke.SYSTEMTIME" /> value.</summary>
      <param name="st">The <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME" /> value.</param>
      <param name="ft">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>ft</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.ToSYSTEMTIME(System.Runtime.InteropServices.ComTypes.FILETIME)</parameter>
          </include>
        </markup>
      </param>
      <returns>The converted <see cref="T:Vanara.PInvoke.SYSTEMTIME" /> value.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.UnregisterApplicationRecoveryCallback">
      <summary>Removes the active instance of an application from the recovery list.</summary>
      <returns>This function returns S_OK on success</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.UnregisterApplicationRestart">
      <summary>Removes the active instance of an application from the restart list.</summary>
      <returns>This function returns S_OK on success</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.UInt32,System.IntPtr,System.Threading.NativeOverlapped*)">
      <summary>
            Writes data to the specified file or input/output (I/O) device.
            <para>This function is designed for both synchronous and asynchronous operation. For a similar function designed solely for asynchronous operation, see WriteFileEx.</para></summary>
      <param name="hFile">A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).
            <para>The hFile parameter must have been created with the write access. For more information, see Generic Access Rights and File Security and Access Rights.</para><para>For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.</para></param>
      <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.
            <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para></param>
      <param name="nNumberOfBytesToWrite">The number of bytes to be written to the file or device.
            <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para><para>Windows Server 2003 and Windows XP:  Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para></param>
      <param name="lpNumberOfBytesWritten">A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter. WriteFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para><para>For more information, see the Remarks section.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
            <para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>To write to the end of file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open hFile using FILE_APPEND_DATA access.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte[],System.UInt32,System.UInt32@,System.IntPtr)">
      <summary>
            Writes data to the specified file or input/output (I/O) device.
            <para>This function is designed for both synchronous and asynchronous operation. For a similar function designed solely for asynchronous operation, see WriteFileEx.</para></summary>
      <param name="hFile">A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).
            <para>The hFile parameter must have been created with the write access. For more information, see Generic Access Rights and File Security and Access Rights.</para><para>For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.</para></param>
      <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.
            <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para></param>
      <param name="nNumberOfBytesToWrite">The number of bytes to be written to the file or device.
            <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para><para>Windows Server 2003 and Windows XP:  Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para></param>
      <param name="lpNumberOfBytesWritten">A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter. WriteFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para><para>For more information, see the Remarks section.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
            <para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>To write to the end of file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open hFile using FILE_APPEND_DATA access.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr)">
      <summary>
            Writes data to the specified file or input/output (I/O) device.
            <para>This function is designed for both synchronous and asynchronous operation. For a similar function designed solely for asynchronous operation, see WriteFileEx.</para></summary>
      <param name="hFile">A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).
            <para>The hFile parameter must have been created with the write access. For more information, see Generic Access Rights and File Security and Access Rights.</para><para>For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.</para></param>
      <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.
            <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para></param>
      <param name="nNumberOfBytesToWrite">The number of bytes to be written to the file or device.
            <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para><para>Windows Server 2003 and Windows XP:  Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para></param>
      <param name="lpNumberOfBytesWritten">A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter. WriteFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
            <para>This parameter can be NULL only when the lpOverlapped parameter is not NULL.</para><para>For more information, see the Remarks section.</para></param>
      <param name="lpOverlapped">A pointer to an OVERLAPPED structure is required if the hFile parameter was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
            <para>For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of the OVERLAPPED structure. For an hFile that does not support byte offsets, Offset and OffsetHigh are ignored.</para><para>To write to the end of file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open hFile using FILE_APPEND_DATA access.</para><para>For more information about different combinations of lpOverlapped and FILE_FLAG_OVERLAPPED, see the Remarks section and the Synchronization and File Position section.</para></param>
      <returns>If the function succeeds, the return value is nonzero (TRUE). If the function fails, or is completing asynchronously, the return value is zero(FALSE). To get extended error information, call the GetLastError function.</returns>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.ACTCTX">
      <summary>The ACTCTX structure is used by the CreateActCtx function to create the activation context.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ACTCTX.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.ACTCTX" /> struct.</summary>
      <param name="source">The source.</param>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.cbSize">
      <summary>The size, in bytes, of this structure. This is used to determine the version of this structure.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.dwFlags">
      <summary>
            Flags that indicate how the values included in this structure are to be used. Set any undefined bits in dwFlags to 0. If any undefined bits are
            not set to 0, the call to CreateActCtx that creates the activation context fails and returns an invalid parameter error code.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.Empty">
      <summary>The empty</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.hModule">
      <summary>
            Use this member rather than lpSource if you have already loaded a DLL and wish to use it to create activation contexts rather than using a path
            in lpSource. See lpResourceName for the rules of looking up resources in this module.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.lpApplicationName">
      <summary>
            The name of the current application. If the value of this member is set to null, the name of the executable that launched the current process is used.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.lpAssemblyDirectory">
      <summary>
            The base directory in which to perform private assembly probing if assemblies in the activation context are not present in the system-wide store.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.lpResourceName">
      <summary>
            Pointer to a null-terminated string that contains the resource name to be loaded from the PE specified in hModule or lpSource. If the resource
            name is an integer, set this member using MAKEINTRESOURCE. This member is required if lpSource refers to an EXE or DLL.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.lpSource">
      <summary>
            Null-terminated string specifying the path of the manifest file or PE image to be used to create the activation context. If this path refers to
            an EXE or DLL file, the lpResourceName member is required.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.wLangId">
      <summary>
            Specifies the language manifest that should be used. The default is the current user's current UI language.
            <para>If the requested language cannot be found, an approximation is searched for using the following order:</para><list type="bullet"><item><description>The current user's specific language. For example, for US English (1033).</description></item><item><description>The current user's primary language. For example, for English (9).</description></item><item><description>The current system's specific language.</description></item><item><description>The current system's primary language.</description></item><item><description>A nonspecific worldwide language. Language neutral (0).</description></item></list></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ACTCTX.wProcessorArchitecture">
      <summary>Identifies the type of processor used. Specifies the system's processor architecture.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.ActCtxFlags">
      <summary>Flags that indicate how the values included in <see cref="T:Vanara.PInvoke.Kernel32.ACTCTX" /> are to be used.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_NONE">
      <summary>No values are set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.wProcessorArchitecture" /> value is set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_LANGID_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.wLangId" /> value is set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.lpAssemblyDirectory" /> value is set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_RESOURCE_NAME_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.lpResourceName" /> value is set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_SET_PROCESS_DEFAULT">
      <summary>Set the activation context to be the process default when calling <see cref="M:Vanara.PInvoke.Kernel32.CreateActCtx(Vanara.PInvoke.Kernel32.ACTCTX@)" />.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_APPLICATION_NAME_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.lpApplicationName" /> value is set.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF">
      <summary>Use when calling <see cref="M:Vanara.PInvoke.Kernel32.CreateActCtx(Vanara.PInvoke.Kernel32.ACTCTX@)" /> to identify that <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.lpSource" /> contains an assembly identifier.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ActCtxFlags.ACTCTX_FLAG_HMODULE_VALID">
      <summary>The <see cref="F:Vanara.PInvoke.Kernel32.ACTCTX.hModule" /> value is set.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.ActCtxSafeHandle">
      <summary>A safe handle for an Activation Context.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ActCtxSafeHandle.#ctor">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.ActCtxSafeHandle" /> class.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.ActCtxSafeHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.ActCtxSafeHandle" /> class.</summary>
      <param name="hActCtx">The h act CTX.</param>
      <param name="ownsHandle">if set to <c>true</c> [owns handle].</param>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.ApplicationRecoveryCallback">
      <summary>
            Application-defined callback function used to save data and application state information in the event the application encounters an unhandled
            exception or becomes unresponsive.
            </summary>
      <param name="pvParameter">Context information specified when you called the RegisterApplicationRecoveryCallback function to register for recovery.</param>
      <returns>The return value is not used and should be 0.</returns>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.ApplicationRestartFlags">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32.ApplicationRestartFlags</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ApplicationRestartFlags.RESTART_NO_CRASH">
      <summary>Do not restart the process if it terminates due to an unhandled exception.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ApplicationRestartFlags.RESTART_NO_HANG">
      <summary>Do not restart the process if it terminates due to the application not responding.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ApplicationRestartFlags.RESTART_NO_PATCH">
      <summary>Do not restart the process if it terminates due to the installation of an update.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.ApplicationRestartFlags.RESTART_NO_REBOOT">
      <summary>Do not restart the process if the computer is restarted as the result of an update.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.DeactivateActCtxFlag">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32.DeactivateActCtxFlag</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.DeactivateActCtxFlag.None">
      <summary>
            If this value is set and the cookie specified in the ulCookie parameter is in the top frame of the activation stack, the activation context is
            popped from the stack and thereby deactivated.
            <para>
            If this value is set and the cookie specified in the ulCookie parameter is not in the top frame of the activation stack, this function searches
            down the stack for the cookie.
            </para><para>If the cookie is found, a STATUS_SXS_EARLY_DEACTIVATION exception is thrown.</para><para>If the cookie is not found, a STATUS_SXS_INVALID_DEACTIVATION exception is thrown.</para><para>This value should be specified in most cases.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.DeactivateActCtxFlag.DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION">
      <summary>
            If this value is set and the cookie specified in the ulCookie parameter is in the top frame of the activation stack, the function returns an
            ERROR_INVALID_PARAMETER error code. Call GetLastError to obtain this code.
            <para>If this value is set and the cookie is not on the activation stack, a STATUS_SXS_INVALID_DEACTIVATION exception will be thrown.</para><para>
            If this value is set and the cookie is in a lower frame of the activation stack, all of the frames down to and including the frame the cookie is
            in is popped from the stack.
            </para></summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.DEVICE_TYPE">
      <summary>Device types defined by the system.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.EnumResNameProc">
      <summary>
            An application-defined callback function used with the EnumResourceNames and EnumResourceNamesEx functions. It receives the type and name of a
            resource. The ENUMRESNAMEPROC type defines a pointer to this callback function. EnumResNameProc is a placeholder for the application-defined function name.
            </summary>
      <param name="hModule">
            A handle to the module whose executable file contains the resources that are being enumerated. If this parameter is NULL, the function enumerates the
            resource names in the module used to create the current process.
            </param>
      <param name="lpszType">
            The type of resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID
            is an integer value representing a predefined resource type. For standard resource types, see Resource Types. For more information, see the Remarks
            section below.
            </param>
      <param name="lpszName">
            The name of a resource of the type being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the
            integer identifier of the resource. For more information, see the Remarks section below.
            </param>
      <param name="lParam">
            An application-defined parameter passed to the EnumResourceNames or EnumResourceNamesEx function. This parameter can be used in error checking.
            </param>
      <returns>Returns TRUE to continue enumeration or FALSE to stop enumeration.</returns>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.FileAccess">
      <summary>Enumerates the that may apply to files.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.GENERIC_READ">
      <summary>Read access.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.GENERIC_WRITE">
      <summary>Write access.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.GENERIC_EXECUTE">
      <summary>Execute access.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.GENERIC_ALL">
      <summary>All possible access rights.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_READ_DATA">
      <summary>
            For a file object, the right to read the corresponding file data. For a directory object, the right to read the corresponding directory data.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_LIST_DIRECTORY">
      <summary>For a directory, the right to list the contents of the directory.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA">
      <summary>
            For a file object, the right to write data to the file. For a directory object, the right to create a file in the directory ( <see cref="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_ADD_FILE" />).
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_ADD_FILE">
      <summary>For a directory, the right to create a file in the directory.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_APPEND_DATA">
      <summary>
            For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing data if this flag is
            specified without <see cref="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA" />.) For a directory object, the right to create a subdirectory ( <see cref="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY" />).
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY">
      <summary>For a directory, the right to create a subdirectory.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_CREATE_PIPE_INSTANCE">
      <summary>For a named pipe, the right to create a pipe.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_READ_EA">
      <summary>The right to read extended file attributes.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_WRITE_EA">
      <summary>The right to write extended file attributes.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_EXECUTE">
      <summary>
            For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the
            script interpreter.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_TRAVERSE">
      <summary>
            For a directory, the right to traverse the directory. By default, users are assigned the BYPASS_TRAVERSE_CHECKING privilege, which ignores the
            FILE_TRAVERSE access right.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_DELETE_CHILD">
      <summary>For a directory, the right to delete a directory and all the files it contains, including read-only files.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_READ_ATTRIBUTES">
      <summary>The right to read file attributes.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileAccess.FILE_WRITE_ATTRIBUTES">
      <summary>The right to write file attributes.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.FileSystemFlags">
      <summary>
            Flags that may be passed to the <see cref="!:GetVolumeInformation(string,System.Text.StringBuilder,int,ref int,ref int,ref FileSystemFlags,System.Text.StringBuilder,int)" /> function.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_CASE_SENSITIVE_SEARCH">
      <summary>The specified volume supports case-sensitive file names.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_CASE_PRESERVED_NAMES">
      <summary>The specified volume supports preserved case of file names when it places a name on disk.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_UNICODE_ON_DISK">
      <summary>The specified volume supports Unicode in file names as they appear on disk.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_PERSISTENT_ACLS">
      <summary>
            The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the
            FAT file system does not.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_FILE_COMPRESSION">
      <summary>The specified volume supports file-based compression.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_VOLUME_QUOTAS">
      <summary>The specified volume supports disk quotas.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_SPARSE_FILES">
      <summary>The specified volume supports sparse files.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_REPARSE_POINTS">
      <summary>The specified volume supports reparse points.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_REMOTE_STORAGE">
      <summary>The specified volume supports remote storage.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_VOLUME_IS_COMPRESSED">
      <summary>The specified volume is a compressed volume, for example, a DoubleSpace volume.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_OBJECT_IDS">
      <summary>The specified volume supports object identifiers.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_ENCRYPTION">
      <summary>
            The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364223(v=vs.85).aspx">File Encryption</a>.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_NAMED_STREAMS">
      <summary>The specified volume supports named streams.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_READ_ONLY_VOLUME">
      <summary>The specified volume is read-only.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SEQUENTIAL_WRITE_ONCE">
      <summary>The specified volume supports a single sequential write.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_TRANSACTIONS">
      <summary>
            The specified volume supports transactions. For more information, see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365993(v=vs.85).aspx">About KTM</a>.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_HARD_LINKS">
      <summary>
            The specified volume supports hard links. For more information, see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365006(v=vs.85).aspx">Hard Links and Junctions.</a><para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This value is not supported until Windows Server 2008 R2 and
            Windows 7.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_EXTENDED_ATTRIBUTES">
      <summary>
            The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can
            associate with a file and is not part of the file's data.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This value is not supported until Windows Server 2008 R2 and
            Windows 7.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_OPEN_BY_FILE_ID">
      <summary>
            The file system supports open by FileID. For more information, see FILE_ID_BOTH_DIR_INFO.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This value is not supported until Windows Server 2008 R2 and
            Windows 7.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_USN_JOURNAL">
      <summary>
            The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363803(v=vs.85).aspx">Change Journal Records</a> .
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This value is not supported until Windows Server 2008 R2 and
            Windows 7.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_INTEGRITY_STREAMS">
      <summary>The specified volume supports integrity streams.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_BLOCK_REFCOUNTING">
      <summary>The specified volume supports block refcounting.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_SPARSE_VDL">
      <summary>The specified volume supports sparse VDL.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_DAX_VOLUME">
      <summary>
            The specified volume is a direct access (DAX) volume.
            <para><c>Note</c> This flag was introduced in Windows 10, version 1607.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_GHOSTING">
      <summary>The specified volume supports ghosting.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.FormatMessageFlags">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32.FormatMessageFlags</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
      <summary>
            The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated buffer at the address specified
            by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate for an output message buffer. The caller should use the
            LocalFree function to free the buffer when it is no longer needed.
            <para>
            If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call to GetLastError will return ERROR_MORE_DATA.
            </para><para>
            In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As of Windows 10 this value can be used.
            </para><para>
            Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then FormatMessage will not automatically fail
            with an error of ERROR_MORE_DATA.
            </para><para>
            Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use HeapFree (GetProcessHeap(),
            allocatedMessage). In this case, this is the same as calling LocalFree on memory.
            </para><para>
            Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED, so HeapFree can be used. If
                       LMEM_MOVABLE is used, HeapFree cannot be used.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
      <summary>
            The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the arguments. This flag cannot be used
            with 64-bit integer values. If you are using a 64-bit integer, you must use the va_list structure.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
      <summary>
            The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource handle is NULL, the current
            process's application image file will be searched. This flag cannot be used with <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            <para>If the module has no message table resource, the function fails with ERROR_RESOURCE_TYPE_NOT_FOUND.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
      <summary>
            The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The message definition may contain insert
            sequences, just as the message text in a message table resource may. This flag cannot be used with <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
      <summary>
            The function should search the system message-table resource(s) for the requested message. If this flag is specified with
            <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the message is not found in the module specified by
            lpSource. This flag cannot be used with <see cref="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            <para>
            If this flag is specified, an application can pass the result of the GetLastError function to retrieve the message text for a system-defined error.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
      <summary>
            Insert sequences in the message definition are to be ignored and passed through to the output buffer unchanged. This flag is useful for fetching
            a message for later formatting. If this flag is set, the Arguments parameter is ignored.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
      <summary>
            The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks in the message definition
            text into the output buffer. The function generates no new line breaks.
            <para>
            Without this flag set: There are no output line width restrictions. The function stores line breaks that are in the message definition text into
            the output buffer. It specifies the maximum number of characters in an output line. The function ignores regular line breaks in the message
            definition text. The function never splits a string delimited by white space across a line break. The function stores hard-coded line breaks in
            the message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
            </para></summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.HeapFlags">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32.HeapFlags</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.HeapFlags.HEAP_NO_SERIALIZE">
      <summary>Serialized access will not be used for this allocation. For more information, see Remarks.
            <para>To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call.</para><para>This value should not be specified when accessing the process's default heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process's default heap.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.HeapFlags.HEAP_GENERATE_EXCEPTIONS">
      <summary>The system will raise an exception to indicate a function failure, such as an out-of-memory condition, instead of returning NULL.
            <para>To ensure that exceptions are generated for all calls to this function, specify HEAP_GENERATE_EXCEPTIONS in the call to HeapCreate. In this case, it is not necessary to additionally specify HEAP_GENERATE_EXCEPTIONS in this function call.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.HeapFlags.HEAP_ZERO_MEMORY">
      <summary>The allocated memory will be initialized to zero. Otherwise, the memory is not initialized to zero.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.HeapFlags.HEAP_CREATE_ENABLE_EXECUTE">
      <summary>All memory blocks that are allocated from this heap allow code execution, if the hardware enforces data execution prevention. Use this flag heap in applications that run code from the heap. If HEAP_CREATE_ENABLE_EXECUTE is not specified and an application attempts to run code from a protected page, the application receives an exception with the status code STATUS_ACCESS_VIOLATION.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.IOAccess">
      <summary>Defined access check value for any access within an I/O control code (IOCTL). The FILE_ACCESS_ANY is generally the correct value.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.IOAccess.FILE_ANY_ACCESS">
      <summary>Request all access.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.IOAccess.FILE_READ_ACCESS">
      <summary>Request read access. Can be used with FILE_WRITE_ACCESS.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.IOAccess.FILE_WRITE_ACCESS">
      <summary>Request write access. Can be used with FILE_READ_ACCESS.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.IOAccess.FILE_READ_WRITE_ACCESS">
      <summary>Request read and write access. This value is equivalent to (FILE_READ_ACCESS | FILE_WRITE_ACCESS).</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.IOControlCode">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>T:Vanara.PInvoke.Kernel32.IOControlCode</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.FSCTL_GET_COMPRESSION">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.FSCTL_GET_COMPRESSION</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.FSCTL_SET_COMPRESSION">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.FSCTL_SET_COMPRESSION</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ALLOCATE_BC_STREAM">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ALLOCATE_BC_STREAM</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_BREAK_RESERVATION">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_BREAK_RESERVATION</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_VERIFY">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_VERIFY</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_VERIFY2">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_CHECK_VERIFY2</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_POWER_CAP">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_POWER_CAP</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EJECT_MEDIA">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EJECT_MEDIA</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EJECTION_CONTROL">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EJECTION_CONTROL</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ENABLE_IDLE_POWER">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_ENABLE_IDLE_POWER</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EVENT_NOTIFICATION">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_EVENT_NOTIFICATION</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIND_NEW_DEVICES">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIND_NEW_DEVICES</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_ACTIVATE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_ACTIVATE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_DOWNLOAD">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_DOWNLOAD</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_GET_INFO">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FIRMWARE_GET_INFO</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FREE_BC_STREAM">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_FREE_BC_STREAM</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_BC_PROPERTIES">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_BC_PROPERTIES</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_COUNTERS">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_COUNTERS</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_NUMBER">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_NUMBER</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_TELEMETRY">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_TELEMETRY</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_HOTPLUG_INFO">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_HOTPLUG_INFO</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_IDLE_POWERUP_REASON">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_IDLE_POWERUP_REASON</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_TYPES">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_TYPES</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_TYPES_EX">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_GET_MEDIA_TYPES_EX</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_LOAD_MEDIA">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_LOAD_MEDIA</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_LOAD_MEDIA2">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_LOAD_MEDIA2</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MCN_CONTROL">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MCN_CONTROL</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MEDIA_REMOVAL">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_MEDIA_REMOVAL</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PERSISTENT_RESERVE_IN">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PERSISTENT_RESERVE_IN</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PERSISTENT_RESERVE_OUT">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PERSISTENT_RESERVE_OUT</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_POWER_ACTIVE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_POWER_ACTIVE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_POWER_IDLE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_POWER_IDLE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PREDICT_FAILURE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PREDICT_FAILURE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PROTOCOL_COMMAND">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_PROTOCOL_COMMAND</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_QUERY_PROPERTY">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_QUERY_PROPERTY</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_READ_CAPACITY">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_READ_CAPACITY</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_REINITIALIZE_MEDIA">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_REINITIALIZE_MEDIA</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RELEASE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RELEASE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESERVE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESERVE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESET_BUS">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESET_BUS</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESET_DEVICE">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RESET_DEVICE</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RPMB_COMMAND">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_RPMB_COMMAND</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_SET_HOTPLUG_INFO">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_SET_HOTPLUG_INFO</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK">
      <summary>
        <markup>
          <include item="SMCMissingTag">
            <parameter>summary</parameter>
            <parameter>P:Vanara.PInvoke.Kernel32.IOControlCode.IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.IOMethod">
      <summary>Defined method codes for how buffers are passed for I/O and file system controls within an I/O control code (IOCTL).</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.LoadLibraryExFlags">
      <summary>Flags that may be passed to the <see cref="M:Vanara.PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,Vanara.PInvoke.Kernel32.LoadLibraryExFlags)" /> function.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.None">
      <summary>Define no flags, the function will behave as <see cref="M:Vanara.PInvoke.Kernel32.LoadLibrary(System.String)" /> does.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES">
      <summary>
            If this value is used, and the executable module is a DLL, the system does not call DllMain for process and thread initialization and
            termination. Also, the system does not load additional executable modules that are referenced by the specified module.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_IGNORE_CODE_AUTHZ_LEVEL">
      <summary>
            If this value is used, the system does not check AppLocker rules or apply Software Restriction Policies for the DLL. This action applies only to
            the DLL being loaded and not to its dependencies. This value is recommended for use in setup programs that must run extracted DLLs during installation.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE">
      <summary>
            If this value is used, the system maps the file into the calling process's virtual address space as if it were a data file. Nothing is done to
            execute or prepare to execute the mapped file. Therefore, you cannot call functions like GetModuleFileName, GetModuleHandle or GetProcAddress
            with this DLL. Using this value causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL only to
            extract messages or resources from it.
            <para>This value can be used with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE">
      <summary>
            Similar to <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />, except that the DLL file is opened with exclusive write access for the calling process. Other
            processes cannot open the DLL file for write access while it is in use. However, the DLL can still be opened by other processes.
            <para>This value can be used with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE">
      <summary>
            If this value is used, the system maps the file into the process's virtual address space as an image file. However, the loader does not load the
            static imports or perform the other usual initialization steps. Use this flag when you want to load a DLL only to extract messages or resources
            from it.
            <para>
            Unless the application depends on the file having the in-memory layout of an image, this value should be used with either 
            <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE" /> or <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />. For more information, see the Remarks section.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR">
      <summary>
            If this value is used, the application's installation directory is searched for the DLL and its dependencies. Directories in the standard search
            path are not searched. This value cannot be combined with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS">
      <summary>
            This value is a combination of <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR" />, <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32" />, and
            <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS" />. Directories in the standard search path are not searched. This value cannot be combined with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            <para>This value represents the recommended maximum number of directories an application should include in its DLL search path.</para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR">
      <summary>
            If this value is used, the directory that contains the DLL is temporarily added to the beginning of the list of directories that are searched for
            the DLL's dependencies. Directories in the standard search path are not searched.
            <para>The lpFileName parameter must specify a fully qualified path. This value cannot be combined with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.</para><para>
            For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading Lib1.dll with this value causes the system to search for Lib2.dll only in
            C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories in the DLL search path, combine this value with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS" />.
            </para></summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32">
      <summary>
            If this value is used, %windows%\system32 is searched for the DLL and its dependencies. Directories in the standard search path are not searched.
            This value cannot be combined with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS">
      <summary>
            If this value is used, directories added using the AddDllDirectory or the SetDllDirectory function are searched for the DLL and its dependencies.
            If more than one directory has been added, the order in which the directories are searched is unspecified. Directories in the standard search
            path are not searched. This value cannot be combined with <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
      <summary>
            If this value is used and lpFileName specifies an absolute path, the system uses the alternate file search strategy discussed in the Remarks
            section to find associated executable modules that the specified module causes to be loaded. If this value is used and lpFileName specifies a
            relative path, the behavior is undefined.
            <para>
            If this value is not used, or if lpFileName does not specify a path, the system uses the standard search strategy discussed in the Remarks
            section to find associated executable modules that the specified module causes to be loaded.
            </para><para>This value cannot be combined with any LOAD_LIBRARY_SEARCH flag.</para></summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.LocalMemoryFlags">
      <summary>The memory allocation attributes.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_FIXED">
      <summary>Allocates fixed memory. The return value is a pointer to the memory object.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_MOVEABLE">
      <summary>
            Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap. The return value is a
            handle to the memory object. To translate the handle to a pointer, use the LocalLock function. This value cannot be combined with LMEM_FIXED.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_NOCOMPACT">
      <summary>Obsolete.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_NODISCARD">
      <summary>Obsolete.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_ZEROINIT">
      <summary>Initializes memory contents to zero.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_MODIFY">
      <summary>
            If the LMEM_MODIFY flag is specified in LocalReAlloc, this parameter modifies the attributes of the memory object, and the uBytes parameter is ignored.
            </summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_DISCARDABLE">
      <summary>Obsolete.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_VALID_FLAGS">
      <summary>Valid flags.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LMEM_INVALID_HANDLE">
      <summary>Indicates that the local handle is not valid</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LHND">
      <summary>Combines LMEM_MOVEABLE and LMEM_ZEROINIT.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.LPTR">
      <summary>Combines LMEM_FIXED and LMEM_ZEROINIT.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.NONZEROLHND">
      <summary>Same as LMEM_MOVEABLE.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.LocalMemoryFlags.NONZEROLPTR">
      <summary>Same as LMEM_FIXED.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.SafeLibraryHandle">
      <summary>A safe handle for HMODULE.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeLibraryHandle.#ctor">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.SafeLibraryHandle" /> class.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.SafeLibraryHandle" /> class.</summary>
      <param name="handle">An existing handle created by <see cref="M:Vanara.PInvoke.Kernel32.LoadLibrary(System.String)" /> or <see cref="M:Vanara.PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,Vanara.PInvoke.Kernel32.LoadLibraryExFlags)" />.</param>
      <param name="own">if set to <c>true</c> calls <see cref="M:Vanara.PInvoke.Kernel32.FreeLibrary(System.IntPtr)" /> on disposal.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.String,Vanara.PInvoke.Kernel32.LoadLibraryExFlags)">
      <summary>Initializes a new instance of the <see cref="!:Vanara.PInvoke.SafeLibraryHandle" /> class.</summary>
      <param name="fileName">
        <para>
            A string that specifies the file name of the module to load. This name is not related to the name stored in a library module itself, as specified
            by the LIBRARY keyword in the module-definition (.def) file.
            </para>
        <para>
            The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static
            imports are not loaded; instead, the module is loaded as if <see cref="F:Vanara.PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES" /> was specified. See the
            <paramref name="flags" /> parameter for more information.
            </para>
        <para>
            If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension
            .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module
            name string.
            </para>
        <para>
            If the string specifies a fully qualified path, the function searches only that path for the module. When specifying a path, be sure to use
            backslashes (\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces.
            </para>
        <para>
            If the string specifies a module name without a path and more than one loaded module has the same base name and extension, the function returns a
            handle to the module that was loaded first.
            </para>
        <para>
            If the string specifies a module name without a path and a module of the same name is not already loaded, or if the string specifies a module
            name with a relative path, the function searches for the specified module. The function also searches for modules if loading the specified module
            causes the system to load other associated modules (that is, if the module has dependencies). The directories that are searched and the order in
            which they are searched depend on the specified path and the dwFlags parameter.
            </para>
        <para>If the function cannot find the module or one of its dependencies, the function fails.</para>
      </param>
      <param name="flags">The action to be taken when loading the module.</param>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.SafeLibraryHandle.Null">
      <summary>A handle that may be used in place of <see cref="F:System.IntPtr.Zero" />.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle">
      <summary>Safe handle for memory heaps.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle.#ctor(Vanara.PInvoke.Kernel32.SafePrivateHeapHandle)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle" /> class.</summary>
      <param name="hHeap">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>hHeap</parameter>
            <parameter>M:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle.#ctor(Vanara.PInvoke.Kernel32.SafePrivateHeapHandle)</parameter>
          </include>
        </markup>
      </param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle.#ctor(Vanara.PInvoke.Kernel32.SafePrivateHeapHandle,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle" /> class and allocates the specified amount of memory from the process heap.</summary>
      <param name="hHeap">A handle to a heap created using <see cref="M:Vanara.PInvoke.Kernel32.HeapCreate(Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr,System.IntPtr)" />.</param>
      <param name="size">The size. This value cannot be zero.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle.#ctor(Vanara.PInvoke.Kernel32.SafePrivateHeapHandle,System.IntPtr,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle" /> class.</summary>
      <param name="hHeap">A handle to a heap created using <see cref="M:Vanara.PInvoke.Kernel32.HeapCreate(Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr,System.IntPtr)" />.</param>
      <param name="ptr">The handle created by <see cref="M:Vanara.PInvoke.Kernel32.HeapAlloc(System.IntPtr,Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr)" />.</param>
      <param name="own">if set to <c>true</c> this safe handle disposes the handle when done.</param>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.SafePrivateHeapBlockHandle.Size">
      <summary>Retrieves the size of this memory block.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle">
      <summary>Safe handle for memory heaps.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle.#ctor">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle" /> class.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle" /> class.</summary>
      <param name="ptr">The handle created by <see cref="M:Vanara.PInvoke.Kernel32.HeapCreate(Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr,System.IntPtr)" />.</param>
      <param name="own">if set to <c>true</c> this safe handle disposes the handle when done.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafePrivateHeapHandle.GetBlock(System.Int32)">
      <summary>Gets a block of memory from this private heap.</summary>
      <param name="size">The size of the block.</param>
      <returns>A safe handle for the memory that will call HeapFree on disposal.</returns>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle">
      <summary>Safe handle for memory heaps.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle.#ctor">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle" /> class.</summary>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle" /> class.</summary>
      <param name="ptr">The handle created by <see cref="M:Vanara.PInvoke.Kernel32.HeapAlloc(System.IntPtr,Vanara.PInvoke.Kernel32.HeapFlags,System.IntPtr)" />.</param>
      <param name="own">if set to <c>true</c> this safe handle disposes the handle when done.</param>
    </member>
    <member name="M:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle.#ctor(System.UInt64)">
      <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle" /> class and allocates the specified amount of memory from the process heap.</summary>
      <param name="size">The size. This value cannot be zero.</param>
    </member>
    <member name="P:Vanara.PInvoke.Kernel32.SafeProcessHeapBlockHandle.Size">
      <summary>Retrieves the size of this memory block.</summary>
    </member>
    <member name="T:Vanara.PInvoke.Kernel32.SymbolicLinkType">
      <summary>Flags used in the <see cref="M:Vanara.PInvoke.Kernel32.CreateSymbolicLink(System.String,System.String,Vanara.PInvoke.Kernel32.SymbolicLinkType)" /> function.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.SymbolicLinkType.SYMBOLIC_LINK_FLAG_FILE">
      <summary>The link target is a file.</summary>
    </member>
    <member name="F:Vanara.PInvoke.Kernel32.SymbolicLinkType.SYMBOLIC_LINK_FLAG_DIRECTORY">
      <summary>The link target is a directory.</summary>
    </member>
  </members>
</doc>