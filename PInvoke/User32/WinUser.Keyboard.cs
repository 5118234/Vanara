using System;
using System.Runtime.InteropServices;

namespace Vanara.PInvoke
{
	public static partial class User32
	{
		/// <summary>Modifiers for key press.</summary>
		[Flags]
		public enum HotKeyModifiers
		{
			/// <summary>Nothing held down.</summary>
			MOD_NONE = 0,

			/// <summary>Either ALT key must be held down.</summary>
			MOD_ALT = 0x0001,

			/// <summary>Either CTRL key must be held down.</summary>
			MOD_CONTROL = 0x0002,

			/// <summary>Either SHIFT key must be held down.</summary>
			MOD_SHIFT = 0x0004,

			/// <summary>
			/// Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS
			/// key are reserved for use by the operating system.
			/// </summary>
			MOD_WIN = 0x0008,

			/// <summary>
			/// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
			/// <para>Windows Vista: This flag is not supported.</para>
			/// </summary>
			MOD_NOREPEAT = 0x4000,
		}

		/// <summary>
		/// <para>Defines a system-wide hot key.</para>
		/// </summary>
		/// <param name="hWnd">
		/// <para>Type: <c>HWND</c></para>
		/// <para>
		/// A handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter is <c>NULL</c>,
		/// <c>WM_HOTKEY</c> messages are posted to the message queue of the calling thread and must be processed in the message loop.
		/// </para>
		/// </param>
		/// <param name="id">
		/// <para>Type: <c>int</c></para>
		/// <para>
		/// The identifier of the hot key. If the hWnd parameter is NULL, then the hot key is associated with the current thread rather than
		/// with a particular window. If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.
		/// </para>
		/// </param>
		/// <param name="fsModifiers">
		/// <para>Type: <c>UINT</c></para>
		/// <para>
		/// The keys that must be pressed in combination with the key specified by the uVirtKey parameter in order to generate the WM_HOTKEY
		/// message. The fsModifiers parameter can be a combination of the following values.
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <term>Value</term>
		/// <term>Meaning</term>
		/// </listheader>
		/// <item>
		/// <term>MOD_ALT 0x0001</term>
		/// <term>Either ALT key must be held down.</term>
		/// </item>
		/// <item>
		/// <term>MOD_CONTROL 0x0002</term>
		/// <term>Either CTRL key must be held down.</term>
		/// </item>
		/// <item>
		/// <term>MOD_NOREPEAT 0x4000</term>
		/// <term>
		/// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications. Windows Vista: This
		/// flag is not supported.
		/// </term>
		/// </item>
		/// <item>
		/// <term>MOD_SHIFT 0x0004</term>
		/// <term>Either SHIFT key must be held down.</term>
		/// </item>
		/// <item>
		/// <term>MOD_WIN 0x0008</term>
		/// <term>
		/// Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS key
		/// are reserved for use by the operating system.
		/// </term>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="vk">
		/// <para>Type: <c>UINT</c></para>
		/// <para>The virtual-key code of the hot key. See Virtual Key Codes.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <c>BOOL</c></para>
		/// <para>If the function succeeds, the return value is nonzero.</para>
		/// <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts the WM_HOTKEY
		/// message to the message queue of the window with which the hot key is associated. If the hot key is not associated with a window,
		/// then the <c>WM_HOTKEY</c> message is posted to the thread associated with the hot key.
		/// </para>
		/// <para>This function cannot associate a hot key with a window created by another thread.</para>
		/// <para><c>RegisterHotKey</c> fails if the keystrokes specified for the hot key have already been registered by another hot key.</para>
		/// <para>
		/// If a hot key already exists with the same hWnd and id parameters, it is maintained along with the new hot key. The application
		/// must explicitly call UnregisterHotKey to unregister the old hot key.
		/// </para>
		/// <para>
		/// <c>Windows Server 2003:</c> If a hot key already exists with the same hWnd and id parameters, it is replaced by the new hot key.
		/// </para>
		/// <para>
		/// The F12 key is reserved for use by the debugger at all times, so it should not be registered as a hot key. Even when you are not
		/// debugging an application, F12 is reserved in case a kernel-mode debugger or a just-in-time debugger is resident.
		/// </para>
		/// <para>
		/// An application must specify an id value in the range 0x0000 through 0xBFFF. A shared DLL must specify a value in the range 0xC000
		/// through 0xFFFF (the range returned by the GlobalAddAtom function). To avoid conflicts with hot-key identifiers defined by other
		/// shared DLLs, a DLL should use the <c>GlobalAddAtom</c> function to obtain the hot-key identifier.
		/// </para>
		/// <para>Examples</para>
		/// <para>
		/// The following example shows how to use the <c>RegisterHotKey</c> function with the <c>MOD_NOREPEAT</c> flag. In this example, the
		/// hotkey 'ALT+b' is registered for the main thread. When the hotkey is pressed, the thread will receive a WM_HOTKEY message, which
		/// will get picked up in the GetMessage call. Because this example uses <c>MOD_ALT</c> with the <c>MOD_NOREPEAT</c> value for
		/// fsModifiers, the thread will only receive another <c>WM_HOTKEY</c> message when the 'b' key is released and then pressed again
		/// while the 'ALT' key is being pressed down.
		/// </para>
		/// </remarks>
		// https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerhotkey BOOL RegisterHotKey( HWND hWnd, int id,
		// UINT fsModifiers, UINT vk );
		[DllImport(Lib.User32, SetLastError = true, ExactSpelling = true)]
		[PInvokeData("winuser.h", MSDNShortId = "registerhotkey")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool RegisterHotKey(HWND hWnd, int id, HotKeyModifiers fsModifiers, uint vk);

		/// <summary>
		/// <para>Frees a hot key previously registered by the calling thread.</para>
		/// </summary>
		/// <param name="hWnd">
		/// <para>Type: <c>HWND</c></para>
		/// <para>
		/// A handle to the window associated with the hot key to be freed. This parameter should be <c>NULL</c> if the hot key is not
		/// associated with a window.
		/// </para>
		/// </param>
		/// <param name="id">
		/// <para>Type: <c>int</c></para>
		/// <para>The identifier of the hot key to be freed.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <c>BOOL</c></para>
		/// <para>If the function succeeds, the return value is nonzero.</para>
		/// <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		// https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-unregisterhotkey BOOL UnregisterHotKey( HWND hWnd, int id );
		[DllImport(Lib.User32, SetLastError = true, ExactSpelling = true)]
		[PInvokeData("winuser.h", MSDNShortId = "unregisterhotkey")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool UnregisterHotKey(HWND hWnd, int id);
	}
}